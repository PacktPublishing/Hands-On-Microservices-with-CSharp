<?xml version="1.0"?>
<doc>
    <assembly>
        <name>NBitcoin</name>
    </assembly>
    <members>
        <member name="T:NBitcoin.Base58Data">
            <summary>
            Base class for all Base58 check representation of data
            </summary>
        </member>
        <member name="T:NBitcoin.BitStream">
            <summary> Provides a view of an array of bits as a stream of bits. </summary>
        </member>
        <member name="T:NBitcoin.GolombRiceFilter">
            <summary>
            Implements a Golomb-coded set to be use in the creation of client-side filter
            for a new kind Bitcoin light clients. This code is based on the BIP:
            https://github.com/bitcoin/bips/blob/master/bip-0158.mediawiki
            </summary>
        </member>
        <member name="P:NBitcoin.GolombRiceFilter.P">
            <summary>
            a value which is computed as 1/fp where fp is the desired false positive rate.
            </summary>
        </member>
        <member name="P:NBitcoin.GolombRiceFilter.N">
            <summary>
            Number of elements in the filter
            </summary>
        </member>
        <member name="P:NBitcoin.GolombRiceFilter.Data">
            <summary>
            Raw filter data
            </summary>
        </member>
        <member name="M:NBitcoin.GolombRiceFilter.Parse(System.String)">
            <summary>
            Creates a new Golomb-Rice filter from the data byte array which 
            contains a serialized filter. Uses the DefaultP value (20).
            </summary>
            <param name="data">A serialized Golomb-Rice filter.</param>
        </member>
        <member name="M:NBitcoin.GolombRiceFilter.#ctor(System.Byte[])">
            <summary>
            Creates a new Golomb-Rice filter from the data byte array which 
            contains a serialized filter. Uses the DefaultP value (20).
            </summary>
            <param name="data">A serialized Golomb-Rice filter.</param>
        </member>
        <member name="M:NBitcoin.GolombRiceFilter.#ctor(System.Byte[],System.Byte)">
            <summary>
            Creates a new Golomb-Rice filter from the data byte array which 
            contains a serialized filter.
            </summary>
            <param name="data">A serialized Golomb-Rice filter.</param>
            <param name="p">The P value to use.</param>
        </member>
        <member name="M:NBitcoin.GolombRiceFilter.#ctor(System.Byte[],System.Int32,System.Byte)">
            <summary>
            Creates a new Golomb-Rice filter from the data byte array.
            </summary>
            <param name="data">A serialized Golomb-Rice filter.</param>
            <param name="n">The number of elements in the filter.</param>
            <param name="p">The P value to use.</param>
        </member>
        <member name="M:NBitcoin.GolombRiceFilter.ConstructHashedSet(System.Byte,System.Int32,System.Byte[],System.Collections.Generic.IEnumerable{System.Byte[]})">
            <summary>
            Computes the sorted-and-uncompressed list of values to be included in the filter.   
            /// </summary>
            <param name="P">P value used.</param>
            <param name="key">Key used for hashing the datalements.</param>
            <param name="data">Data elements to be computed in the list.</param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.GolombRiceFilter.GetHeader(NBitcoin.uint256)">
            <summary>
            Calculates the filter's header.
            </summary>
            <param name="previousHeader">Previous filter header.</param>
            <returns>The filter header.</returns>
        </member>
        <member name="M:NBitcoin.GolombRiceFilter.Match(System.Byte[],System.Byte[])">
            <summary>
            Checks if the value passed is in the filter.
            </summary>
            <param name="data">Data element to check in the filter.</param>
            <param name="key">Key used for hashing the data elements.</param>
            <returns>true if the element is in the filter, otherwise false.</returns>
        </member>
        <member name="M:NBitcoin.GolombRiceFilter.MatchAny(System.Collections.Generic.IEnumerable{System.Byte[]},System.Byte[])">
            <summary>
            Checks if any of the provided elements is in the filter.
            </summary>
            <param name="data">Data elements to check in the filter.</param>
            <param name="key">Key used for hashing the data elements.</param>
            <returns>true if at least one of the elements is in the filter, otherwise false.</returns>
        </member>
        <member name="M:NBitcoin.GolombRiceFilter.ToBytes">
            <summary>
            Serialize the filter as a array of bytes using [varint(N) | data]. 
            </summary>
            <returns>A array of bytes with the serialized filter data.</returns>
        </member>
        <member name="M:NBitcoin.GolombRiceFilter.ToString">
            <summary>
            Serialize the filter as hexadecimal string. 
            </summary>
            <returns>A string with the serialized filter data</returns>
        </member>
        <member name="T:NBitcoin.GolombRiceFilterBuilder">
            <summary>
            Class for creating Golomb-Rice filters for a given block.
            It provides methods for building two kind of filters out-of-the-box:
            Basic Filters and Extenden Filters.
            </summary>
        </member>
        <member name="T:NBitcoin.GolombRiceFilterBuilder.ByteArrayComparer">
            <summary>
            Helper class for making sure not two ideantical data elements are 
            included in a filter.
            </summary>
        </member>
        <member name="M:NBitcoin.GolombRiceFilterBuilder.BuildBasicFilter(NBitcoin.Block)">
             <summary>
             Builds the basic filter for a given block.
            
             The basic filter is designed to contain everything that a light client needs to sync a regular Bitcoin wallet. 
             A basic filter MUST contain exactly the following items for each transaction in a block:
              * The outpoint of each input, except for the coinbase transaction
              * The scriptPubKey of each output
              * The txid of the transaction itself
             </summary>
             <param name="block">The block used for building the filter.</param>
             <returns>The basic filter for the block.</returns>
        </member>
        <member name="M:NBitcoin.GolombRiceFilterBuilder.BuildExtendedFilter(NBitcoin.Block)">
             <summary>
             Builds the extended filter for a given block.
            
             The extended filter contains extra data that is meant to enable applications with more advanced smart contracts. 
             An extended filter MUST contain exactly the following items for each transaction in a block except the coinbase:
              * Each item within the witness stack of each input (if the input has a witness)
              * Each data push in the scriptSig of each input
             </summary>
             <param name="block">The block used for building the filter.</param>
             <returns>The extended filter for the block.</returns>
        </member>
        <member name="M:NBitcoin.GolombRiceFilterBuilder.#ctor">
            <summary>
            Creates a new Golob-Rice filter builder.
            </summary>
        </member>
        <member name="M:NBitcoin.GolombRiceFilterBuilder.SetKey(NBitcoin.uint256)">
            <summary>
            Sets the key used for hashing the filter data elements.
            The first half of the block hash is used as described in the BIP.
            </summary>
            <param name="blockHash">The block hash which the hashing key is derived from.</param>
            <returns>The updated filter builder instance</returns>
        </member>
        <member name="M:NBitcoin.GolombRiceFilterBuilder.SetP(System.Int32)">
            <summary>
            Sets the P value to use.
            </summary>
            <param name="p">P value</param>
            <returns>The updated filter builder instance.</returns>
        </member>
        <member name="M:NBitcoin.GolombRiceFilterBuilder.AddTxId(NBitcoin.uint256)">
            <summary>
            Adds a transacion id to the list of elements that will be used for building the filter.
            </summary>
            <param name="id">The transaction id.</param>
            <returns>The updated filter builder instance.</returns>
        </member>
        <member name="M:NBitcoin.GolombRiceFilterBuilder.AddScriptPubkey(NBitcoin.Script)">
            <summary>
            Adds a scriptPubKey to the list of elements that will be used for building the filter.
            </summary>
            <param name="scriptPubkey">The scriptPubkey.</param>
            <returns>The updated filter builder instance.</returns>
        </member>
        <member name="M:NBitcoin.GolombRiceFilterBuilder.AddScriptSig(NBitcoin.Script)">
            <summary>
            Adds a scriptSig to the list of elements that will be used for building the filter.
            </summary>
            <param name="scriptSig">The scriptSig.</param>
            <returns>The updated filter builder instance.</returns>
        </member>
        <member name="M:NBitcoin.GolombRiceFilterBuilder.AddWitness(NBitcoin.WitScript)">
            <summary>
            Adds a witness stack to the list of elements that will be used for building the filter.
            </summary>
            <param name="witScript">The witScript.</param>
            <returns>The updated filter builder instance.</returns>
        </member>
        <member name="M:NBitcoin.GolombRiceFilterBuilder.AddOutPoint(NBitcoin.OutPoint)">
            <summary>
            Adds an outpoint to the list of elements that will be used for building the filter.
            </summary>
            <param name="outpoint">The outpoint.</param>
            <returns>The updated filter builder instance.</returns>
        </member>
        <member name="M:NBitcoin.GolombRiceFilterBuilder.AddEntries(System.Collections.Generic.IEnumerable{System.Byte[]})">
            <summary>
            Adds a list of elements to the list of elements that will be used for building the filter.
            </summary>
            <param name="entries">The entries.</param>
            <returns>The updated filter builder instance.</returns>
        </member>
        <member name="M:NBitcoin.GolombRiceFilterBuilder.Build">
            <summary>
            Builds the Golomb-Rice filters from the parameters and data elements included.
            </summary>
            <returns>The built filter.</returns>
        </member>
        <member name="T:NBitcoin.BitcoinExtKey">
            <summary>
            Base58 representation of an ExtKey, within a particular network.
            </summary>
        </member>
        <member name="M:NBitcoin.BitcoinExtKey.#ctor(System.String,NBitcoin.Network)">
            <summary>
            Constructor. Creates an extended key from the Base58 representation, checking the expected network.
            </summary>
        </member>
        <member name="M:NBitcoin.BitcoinExtKey.#ctor(NBitcoin.ExtKey,NBitcoin.Network)">
            <summary>
            Constructor. Creates a representation of an extended key, within the specified network.
            </summary>
        </member>
        <member name="P:NBitcoin.BitcoinExtKey.IsValid">
            <summary>
            Gets whether the data is the correct expected length.
            </summary>
        </member>
        <member name="P:NBitcoin.BitcoinExtKey.ExtKey">
            <summary>
            Gets the extended key, converting from the Base58 representation.
            </summary>
        </member>
        <member name="P:NBitcoin.BitcoinExtKey.Type">
            <summary>
            Gets the type of item represented by this Base58 data.
            </summary>
        </member>
        <member name="P:NBitcoin.BitcoinExtKey.ScriptPubKey">
            <summary>
            Gets the script of the hash of the public key corresponing to the private key 
            of the extended key of this Base58 item.
            </summary>
        </member>
        <member name="M:NBitcoin.BitcoinExtKey.Neuter">
            <summary>
            Gets the Base58 representation, in the same network, of the neutered extended key.
            </summary>
        </member>
        <member name="P:NBitcoin.BitcoinExtKey.PrivateKey">
            <summary>
            Gets the private key of the extended key of this Base58 item.
            </summary>
        </member>
        <member name="M:NBitcoin.BitcoinExtKey.op_Implicit(NBitcoin.BitcoinExtKey)~NBitcoin.ExtKey">
            <summary>
            Implicit cast from BitcoinExtKey to ExtKey.
            </summary>
        </member>
        <member name="T:NBitcoin.BitcoinExtPubKey">
            <summary>
            Base58 representation of an ExtPubKey, within a particular network.
            </summary>
        </member>
        <member name="M:NBitcoin.BitcoinExtPubKey.#ctor(System.String,NBitcoin.Network)">
            <summary>
            Constructor. Creates an extended public key from the Base58 representation, checking the expected network.
            </summary>
        </member>
        <member name="M:NBitcoin.BitcoinExtPubKey.#ctor(NBitcoin.ExtPubKey,NBitcoin.Network)">
            <summary>
            Constructor. Creates a representation of an extended public key, within the specified network.
            </summary>
        </member>
        <member name="P:NBitcoin.BitcoinExtPubKey.ExtPubKey">
            <summary>
            Gets the extended public key, converting from the Base58 representation.
            </summary>
        </member>
        <member name="P:NBitcoin.BitcoinExtPubKey.Type">
            <summary>
            Gets the type of item represented by this Base58 data.
            </summary>
        </member>
        <member name="P:NBitcoin.BitcoinExtPubKey.ScriptPubKey">
            <summary>
            Gets the script of the hash of the public key of the extended key of this Base58 item.
            </summary>
        </member>
        <member name="M:NBitcoin.BitcoinExtPubKey.op_Implicit(NBitcoin.BitcoinExtPubKey)~NBitcoin.ExtPubKey">
            <summary>
            Implicit cast from BitcoinExtPubKey to ExtPubKey.
            </summary>
        </member>
        <member name="T:NBitcoin.ExtKey">
            <summary>
            A private Hierarchical Deterministic key
            </summary>
        </member>
        <member name="M:NBitcoin.ExtKey.Parse(System.String,NBitcoin.Network)">
            <summary>
            Parses the Base58 data (checking the network if specified), checks it represents the
            correct type of item, and then returns the corresponding ExtKey.
            </summary>
        </member>
        <member name="P:NBitcoin.ExtKey.Depth">
            <summary>
            Gets the depth of this extended key from the root key.
            </summary>
        </member>
        <member name="P:NBitcoin.ExtKey.Child">
            <summary>
            Gets the child number of this key (in reference to the parent).
            </summary>
        </member>
        <member name="M:NBitcoin.ExtKey.#ctor(NBitcoin.BitcoinExtPubKey,NBitcoin.BitcoinSecret)">
            <summary>
            Constructor. Reconstructs an extended key from the Base58 representations of 
            the public key and corresponding private key.  
            </summary>
        </member>
        <member name="M:NBitcoin.ExtKey.#ctor(NBitcoin.ExtPubKey,NBitcoin.Key)">
            <summary>
            Constructor. Creates an extended key from the public key and corresponding private key.  
            </summary>
            <remarks>
            <para>
            The ExtPubKey has the relevant values for child number, depth, chain code, and fingerprint.
            </para>
            </remarks>
        </member>
        <member name="M:NBitcoin.ExtKey.#ctor(NBitcoin.Key,System.Byte[],System.Byte,System.Byte[],System.UInt32)">
            <summary>
            Constructor. Creates an extended key from the private key, and specified values for
            chain code, depth, fingerprint, and child number.
            </summary>
        </member>
        <member name="M:NBitcoin.ExtKey.#ctor(NBitcoin.Key,System.Byte[])">
            <summary>
            Constructor. Creates an extended key from the private key, with the specified value
            for chain code. Depth, fingerprint, and child number, will have their default values.
            </summary>
        </member>
        <member name="M:NBitcoin.ExtKey.#ctor">
            <summary>
            Constructor. Creates a new extended key with a random 64 byte seed.
            </summary>
        </member>
        <member name="M:NBitcoin.ExtKey.#ctor(System.String)">
            <summary>
            Constructor. Creates a new extended key from the specified seed bytes, from the given hex string.
            </summary>
        </member>
        <member name="M:NBitcoin.ExtKey.#ctor(System.Byte[])">
            <summary>
            Constructor. Creates a new extended key from the specified seed bytes.
            </summary>
        </member>
        <member name="P:NBitcoin.ExtKey.PrivateKey">
            <summary>
            Get the private key of this extended key.
            </summary>
        </member>
        <member name="M:NBitcoin.ExtKey.Neuter">
            <summary>
            Create the public key from this key.
            </summary>
        </member>
        <member name="M:NBitcoin.ExtKey.Derive(System.UInt32)">
            <summary>
            Derives a new extended key in the hierarchy as the given child number.
            </summary>
        </member>
        <member name="M:NBitcoin.ExtKey.Derive(System.Int32,System.Boolean)">
            <summary>
            Derives a new extended key in the hierarchy as the given child number, 
            setting the high bit if hardened is specified.
            </summary>
        </member>
        <member name="M:NBitcoin.ExtKey.Derive(NBitcoin.KeyPath)">
            <summary>
            Derives a new extended key in the hierarchy at the given path below the current key,
            by deriving the specified child at each step.
            </summary>
        </member>
        <member name="M:NBitcoin.ExtKey.GetWif(NBitcoin.Network)">
            <summary>
            Converts the extended key to the base58 representation, within the specified network.
            </summary>
        </member>
        <member name="M:NBitcoin.ExtKey.ToString(NBitcoin.Network)">
            <summary>
            Converts the extended key to the base58 representation, as a string, within the specified network.
            </summary>
        </member>
        <member name="P:NBitcoin.ExtKey.ScriptPubKey">
            <summary>
            Gets the script of the hash of the public key corresponding to the private key.
            </summary>
        </member>
        <member name="P:NBitcoin.ExtKey.IsHardened">
            <summary>
            Gets whether or not this extended key is a hardened child.
            </summary>
        </member>
        <member name="M:NBitcoin.ExtKey.GetParentExtKey(NBitcoin.ExtPubKey)">
            <summary>
            Recreates the private key of the parent from the private key of the child 
            combinated with the public key of the parent (hardened children cannot be
            used to recreate the parent).
            </summary>
        </member>
        <member name="T:NBitcoin.ExtPubKey">
            <summary>
            A public HD key
            </summary>
        </member>
        <member name="P:NBitcoin.ExtPubKey.ScriptPubKey">
            <summary>
            The P2PKH payment script
            </summary>
        </member>
        <member name="T:NBitcoin.KeyPath">
            <summary>
            Represent a path in the hierarchy of HD keys (BIP32)
            </summary>
        </member>
        <member name="M:NBitcoin.KeyPath.Parse(System.String)">
            <summary>
            Parse a KeyPath
            </summary>
            <param name="path">The KeyPath formated like 10/0/2'/3</param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.BitcoinEncryptedSecretEC.HashAddress(NBitcoin.BitcoinAddress)">
            <summary>
            Take the first four bytes of SHA256(SHA256(generatedaddress)) and call it addresshash.
            </summary>
            <param name="address"></param>
            <returns></returns>
        </member>
        <member name="T:NBitcoin.Mnemonic">
            <summary>
            A .NET implementation of the Bitcoin Improvement Proposal - 39 (BIP39)
            BIP39 specification used as reference located here: https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki
            Made by thashiznets@yahoo.com.au
            v1.0.1.1
            I ♥ Bitcoin :)
            Bitcoin:1ETQjMkR1NNh4jwLuN5LxY7bMsHC9PUPSV
            </summary>
        </member>
        <member name="M:NBitcoin.Mnemonic.#ctor(NBitcoin.Wordlist,System.Byte[])">
            <summary>
            Generate a mnemonic
            </summary>
            <param name="wordList"></param>
            <param name="entropy"></param>
        </member>
        <member name="M:NBitcoin.Wordlist.#ctor(System.String[],System.Char,System.String)">
            <summary>
            Constructor used by inheritence only
            </summary>
            <param name="words">The words to be used in the wordlist</param>
        </member>
        <member name="M:NBitcoin.Wordlist.WordExists(System.String,System.Int32@)">
            <summary>
            Method to determine if word exists in word list, great for auto language detection
            </summary>
            <param name="word">The word to check for existence</param>
            <returns>Exists (true/false)</returns>
        </member>
        <member name="M:NBitcoin.Wordlist.GetWordAtIndex(System.Int32)">
            <summary>
            Returns a string containing the word at the specified index of the wordlist
            </summary>
            <param name="index">Index of word to return</param>
            <returns>Word</returns>
        </member>
        <member name="P:NBitcoin.Wordlist.WordCount">
            <summary>
            The number of all the words in the wordlist
            </summary>
        </member>
        <member name="F:NBitcoin.BIP9DeploymentsParameters.AlwaysActive">
            <summary>Special flag for timeout to indicate always active.</summary>
        </member>
        <member name="T:NBitcoin.BitcoinScriptAddress">
            <summary>
            Base58 representaiton of a script hash
            </summary>
        </member>
        <member name="T:NBitcoin.BitcoinAddress">
            <summary>
            Base58 representation of a bitcoin address
            </summary>
        </member>
        <member name="M:NBitcoin.BitcoinAddress.Create(System.String,NBitcoin.Network)">
            <summary>
            Detect whether the input base58 is a pubkey hash or a script hash
            </summary>
            <param name="str">The string to parse</param>
            <param name="expectedNetwork">The expected network to which it belongs</param>
            <returns>A BitcoinAddress or BitcoinScriptAddress</returns>
            <exception cref="T:System.FormatException">Invalid format</exception>
        </member>
        <member name="M:NBitcoin.BitcoinAddress.Create(System.String)">
            <summary>
            Detect whether the input base58 is a pubkey hash or a script hash
            </summary>
            <param name="str">The string to parse</param>
            <returns>A BitcoinAddress or BitcoinScriptAddress</returns>
            <exception cref="T:System.FormatException">Invalid format</exception>
        </member>
        <member name="M:NBitcoin.BitcoinCore.BlockStore.Enumerate(System.Boolean,System.Int32,System.Int32)">
            <summary>
            
            </summary>
            <param name="headersOnly"></param>
            <param name="blockStart">Inclusive block count</param>
            <param name="blockEnd">Exclusive block count</param>
            <returns></returns>
        </member>
        <member name="T:NBitcoin.BitcoinCore.TxInUndo">
            Undo information for a CTxIn
            
              Contains the prevout's CTxOut being spent, and if this was the
              last output of the affected transaction, its metadata as well
              (coinbase or not, height, transaction version)
        </member>
        <member name="M:NBitcoin.BitcoinCore.DiskBlockPosRange.#ctor(NBitcoin.BitcoinCore.DiskBlockPos,NBitcoin.BitcoinCore.DiskBlockPos)">
            <summary>
            Represent a disk block range
            </summary>
            <param name="begin">Beginning of the range (included)</param>
            <param name="end">End of the range (excluded)</param>
        </member>
        <member name="T:NBitcoin.IPubkeyHashUsable">
            <summary>
            Abstracts an object able to verify messages from which it is possible to extract public key.
            </summary>
        </member>
        <member name="T:NBitcoin.BitcoinPubKeyAddress">
            <summary>
            Base58 representation of a pubkey hash and base class for the representation of a script hash
            </summary>
        </member>
        <member name="P:NBitcoin.BitcoinStream.ConsensusFactory">
            <summary>
            Set the format to use when serializing and deserializing consensus related types.
            </summary>
        </member>
        <member name="T:NBitcoin.BlockHeader">
            <summary>
            Nodes collect new transactions into a block, hash them into a hash tree,
            and scan through nonce values to make the block's hash satisfy proof-of-work
            requirements.  When they solve the proof-of-work, they broadcast the block
            to everyone and the block is added to the block chain.  The first transaction
            in the block is a special one that creates a new coin owned by the creator
            of the block.
            </summary>
        </member>
        <member name="M:NBitcoin.BlockHeader.PrecomputeHash(System.Boolean,System.Boolean)">
            <summary>
            Precompute the block header hash so that later calls to GetHash() will returns the precomputed hash
            </summary>
            <param name="invalidateExisting">If true, the previous precomputed hash is thrown away, else it is reused</param>
            <param name="lazily">If true, the hash will be calculated and cached at the first call to GetHash(), else it will be immediately</param>
        </member>
        <member name="M:NBitcoin.BlockHeader.UpdateTime(NBitcoin.Network,NBitcoin.ChainedBlock)">
            <summary>
            Set time to consensus acceptable value
            </summary>
            <param name="network">Network</param>
            <param name="prev">previous block</param>
        </member>
        <member name="M:NBitcoin.BlockHeader.UpdateTime(NBitcoin.Consensus,NBitcoin.ChainedBlock)">
            <summary>
            Set time to consensus acceptable value
            </summary>
            <param name="consensus">Consensus</param>
            <param name="prev">previous block</param>
        </member>
        <member name="M:NBitcoin.BlockHeader.UpdateTime(System.DateTimeOffset,NBitcoin.Consensus,NBitcoin.ChainedBlock)">
            <summary>
            Set time to consensus acceptable value
            </summary>
            <param name="now">The expected date</param>
            <param name="consensus">Consensus</param>
            <param name="prev">previous block</param>		
        </member>
        <member name="M:NBitcoin.BlockHeader.UpdateTime(System.DateTimeOffset,NBitcoin.Network,NBitcoin.ChainedBlock)">
            <summary>
            Set time to consensus acceptable value
            </summary>
            <param name="now">The expected date</param>
            <param name="network">Network</param>
            <param name="prev">previous block</param>		
        </member>
        <member name="M:NBitcoin.Block.WithOptions(NBitcoin.TransactionOptions)">
            <summary>
            Create a block with the specified option only. (useful for stripping data from a block)
            </summary>
            <param name="options">Options to keep</param>
            <returns>A new block with only the options wanted</returns>
        </member>
        <member name="M:NBitcoin.Block.Check">
            <summary>
            Check proof of work and merkle root
            </summary>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.Block.Check(NBitcoin.Consensus)">
            <summary>
            Check proof of work and merkle root
            </summary>
            <param name="consensus"></param>
            <returns></returns>
        </member>
        <member name="T:NBitcoin.BlockLocator">
            <summary>
            Compact representation of one's chain position which can be used to find forks with another chain
            </summary>
        </member>
        <member name="T:NBitcoin.BloomFilter">
            <summary>
            Used by SPV client, represent the set of interesting addresses tracked by SPV client with plausible deniability
            </summary>
        </member>
        <member name="T:NBitcoin.BouncyCastle.Asn1.Asn1InputStream">
            a general purpose ASN.1 decoder - note: this class differs from the
            others in that it returns null after it has read the last object in
            the stream. If an ASN.1 Null is encountered a Der/BER Null object is
            returned.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Asn1.Asn1InputStream.#ctor(System.IO.Stream,System.Int32)">
             Create an ASN1InputStream where no DER object will be longer than limit.
            
             @param input stream containing ASN.1 encoded data.
             @param limit maximum size of a DER encoded object.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Asn1.Asn1InputStream.#ctor(System.Byte[])">
             Create an ASN1InputStream based on the input byte array. The length of DER objects in
             the stream is automatically limited to the length of the input array.
            
             @param input array containing ASN.1 encoded data.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Asn1.Asn1InputStream.BuildObject(System.Int32,System.Int32,System.Int32)">
            build an object given its tag and the number of bytes to construct it from.
        </member>
        <member name="T:NBitcoin.BouncyCastle.Asn1.Asn1Null">
            A Null object.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Asn1.Asn1Object.FromByteArray(System.Byte[])">
            <summary>Create a base ASN.1 object from a byte array.</summary>
            <param name="data">The byte array to parse.</param>
            <returns>The base ASN.1 object represented by the byte array.</returns>
            <exception cref="T:System.IO.IOException">If there is a problem parsing the data.</exception>
        </member>
        <member name="M:NBitcoin.BouncyCastle.Asn1.Asn1Object.FromStream(System.IO.Stream)">
            <summary>Read a base ASN.1 object from a stream.</summary>
            <param name="inStr">The stream to parse.</param>
            <returns>The base ASN.1 object represented by the byte array.</returns>
            <exception cref="T:System.IO.IOException">If there is a problem parsing the data.</exception>
        </member>
        <member name="M:NBitcoin.BouncyCastle.Asn1.Asn1OctetString.#ctor(System.Byte[])">
            @param string the octets making up the octet string.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Asn1.Asn1Sequence.GetInstance(System.Object)">
             return an Asn1Sequence from the given object.
            
             @param obj the object we want converted.
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="P:NBitcoin.BouncyCastle.Asn1.Asn1Sequence.Item(System.Int32)">
             return the object at the sequence position indicated by index.
            
             @param index the sequence number (starting at zero) of the object
             @return the object at the sequence position indicated by index.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Asn1.DerInteger.GetInstance(System.Object)">
             return an integer from the passed in object
            
             @exception ArgumentException if the object cannot be converted.
        </member>
        <member name="P:NBitcoin.BouncyCastle.Asn1.DerInteger.PositiveValue">
            in some cases positive values Get crammed into a space,
            that's not quite big enough...
        </member>
        <member name="T:NBitcoin.BouncyCastle.Asn1.DerNull">
            A Null object.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Asn1.DerObjectIdentifier.On(NBitcoin.BouncyCastle.Asn1.DerObjectIdentifier)">
            Return  true if this oid is an extension of the passed in branch, stem.
            @param stem the arc or branch that is a possible parent.
            @return  true if the branch is on the passed in stem, false otherwise.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Asn1.DerOctetString.#ctor(System.Byte[])">
            <param name="str">The octets making up the octet string.</param>
        </member>
        <member name="M:NBitcoin.BouncyCastle.Asn1.DerSequence.#ctor">
            create an empty sequence
        </member>
        <member name="M:NBitcoin.BouncyCastle.Asn1.DerSequence.#ctor(NBitcoin.BouncyCastle.Asn1.Asn1Encodable)">
            create a sequence containing one object
        </member>
        <member name="M:NBitcoin.BouncyCastle.Asn1.DerSequence.#ctor(NBitcoin.BouncyCastle.Asn1.Asn1EncodableVector)">
            create a sequence containing a vector of objects.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Asn1.Sec.SecNamedCurves.GetByOid(NBitcoin.BouncyCastle.Asn1.DerObjectIdentifier)">
             return the X9ECParameters object for the named curve represented by
             the passed in object identifier. Null if the curve isn't present.
            
             @param oid an object identifier representing a named curve, if present.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Asn1.Sec.SecNamedCurves.GetOid(System.String)">
             return the object identifier signified by the passed in name. Null
             if there is no object identifier associated with name.
            
             @return the object identifier associated with name, if present.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Asn1.Sec.SecNamedCurves.GetName(NBitcoin.BouncyCastle.Asn1.DerObjectIdentifier)">
            return the named curve name represented by the given object identifier.
        </member>
        <member name="F:NBitcoin.BouncyCastle.Asn1.Sec.SecObjectIdentifiers.EllipticCurve">
            EllipticCurve OBJECT IDENTIFIER ::= {
                  iso(1) identified-organization(3) certicom(132) curve(0)
            }
        </member>
        <member name="T:NBitcoin.BouncyCastle.Asn1.X9.X9Curve">
            ASN.1 def for Elliptic-Curve Curve structure. See
            X9.62, for further details.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Asn1.X9.X9Curve.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
             Curve ::= Sequence {
                 a               FieldElement,
                 b               FieldElement,
                 seed            BIT STRING      OPTIONAL
             }
            </pre>
        </member>
        <member name="T:NBitcoin.BouncyCastle.Asn1.X9.X9ECParameters">
            ASN.1 def for Elliptic-Curve ECParameters structure. See
            X9.62, for further details.
        </member>
        <member name="P:NBitcoin.BouncyCastle.Asn1.X9.X9ECParameters.CurveEntry">
             Return the ASN.1 entry representing the Curve.
            
             @return the X9Curve for the curve in these parameters.
        </member>
        <member name="P:NBitcoin.BouncyCastle.Asn1.X9.X9ECParameters.FieldIDEntry">
             Return the ASN.1 entry representing the FieldID.
            
             @return the X9FieldID for the FieldID in these parameters.
        </member>
        <member name="P:NBitcoin.BouncyCastle.Asn1.X9.X9ECParameters.BaseEntry">
             Return the ASN.1 entry representing the base point G.
            
             @return the X9ECPoint for the base point in these parameters.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Asn1.X9.X9ECParameters.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
             ECParameters ::= Sequence {
                 version         Integer { ecpVer1(1) } (ecpVer1),
                 fieldID         FieldID {{FieldTypes}},
                 curve           X9Curve,
                 base            X9ECPoint,
                 order           Integer,
                 cofactor        Integer OPTIONAL
             }
            </pre>
        </member>
        <member name="T:NBitcoin.BouncyCastle.Asn1.X9.X9ECPoint">
            class for describing an ECPoint as a Der object.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Asn1.X9.X9ECPoint.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
             ECPoint ::= OCTET STRING
            </pre>
            <p>
            Octet string produced using ECPoint.GetEncoded().</p>
        </member>
        <member name="T:NBitcoin.BouncyCastle.Asn1.X9.X9FieldElement">
            Class for processing an ECFieldElement as a DER object.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Asn1.X9.X9FieldElement.ToAsn1Object">
            Produce an object suitable for an Asn1OutputStream.
            <pre>
             FieldElement ::= OCTET STRING
            </pre>
            <p>
            <ol>
            <li> if <i>q</i> is an odd prime then the field element is
            processed as an Integer and converted to an octet string
            according to x 9.62 4.3.1.</li>
            <li> if <i>q</i> is 2<sup>m</sup> then the bit string
            contained in the field element is converted into an octet
            string with the same ordering padded at the front if necessary.
            </li>
            </ol>
            </p>
        </member>
        <member name="T:NBitcoin.BouncyCastle.Asn1.X9.X9FieldID">
            ASN.1 def for Elliptic-Curve Field ID structure. See
            X9.62, for further details.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Asn1.X9.X9FieldID.#ctor(NBitcoin.BouncyCastle.Math.BigInteger)">
            Constructor for elliptic curves over prime fields
            <code>F<sub>2</sub></code>.
            @param primeP The prime <code>p</code> defining the prime field.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Asn1.X9.X9FieldID.#ctor(System.Int32,System.Int32)">
            Constructor for elliptic curves over binary fields
            <code>F<sub>2<sup>m</sup></sub></code>.
            @param m  The exponent <code>m</code> of
            <code>F<sub>2<sup>m</sup></sub></code>.
            @param k1 The integer <code>k1</code> where <code>x<sup>m</sup> +
            x<sup>k1</sup> + 1</code>
            represents the reduction polynomial <code>f(z)</code>.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Asn1.X9.X9FieldID.#ctor(System.Int32,System.Int32,System.Int32,System.Int32)">
            Constructor for elliptic curves over binary fields
            <code>F<sub>2<sup>m</sup></sub></code>.
            @param m  The exponent <code>m</code> of
            <code>F<sub>2<sup>m</sup></sub></code>.
            @param k1 The integer <code>k1</code> where <code>x<sup>m</sup> +
            x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
            represents the reduction polynomial <code>f(z)</code>.
            @param k2 The integer <code>k2</code> where <code>x<sup>m</sup> +
            x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
            represents the reduction polynomial <code>f(z)</code>.
            @param k3 The integer <code>k3</code> where <code>x<sup>m</sup> +
            x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
            represents the reduction polynomial <code>f(z)</code>..
        </member>
        <member name="M:NBitcoin.BouncyCastle.Asn1.X9.X9FieldID.ToAsn1Object">
            Produce a Der encoding of the following structure.
            <pre>
             FieldID ::= Sequence {
                 fieldType       FIELD-ID.&amp;id({IOSet}),
                 parameters      FIELD-ID.&amp;Type({IOSet}{&#64;fieldType})
             }
            </pre>
        </member>
        <member name="F:NBitcoin.BouncyCastle.Asn1.X9.X9ObjectIdentifiers.IdDsaWithSha1">
            id-dsa-with-sha1 OBJECT IDENTIFIER ::=  { iso(1) member-body(2)
                  us(840) x9-57 (10040) x9cm(4) 3 }
        </member>
        <member name="F:NBitcoin.BouncyCastle.Asn1.X9.X9ObjectIdentifiers.X9x63Scheme">
            X9.63
        </member>
        <member name="F:NBitcoin.BouncyCastle.Asn1.X9.X9ObjectIdentifiers.ansi_x9_42">
            X9.42
        </member>
        <member name="T:NBitcoin.BouncyCastle.Crypto.BufferedBlockCipher">
            A wrapper class that allows block ciphers to be used to process data in
            a piecemeal fashion. The BufferedBlockCipher outputs a block only when the
            buffer is full and more data is being added, or on a doFinal.
            <p>
            Note: in the case where the underlying cipher is either a CFB cipher or an
            OFB one the last block may not be a multiple of the block size.
            </p>
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.BufferedBlockCipher.#ctor">
            constructor for subclasses
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.BufferedBlockCipher.#ctor(NBitcoin.BouncyCastle.Crypto.IBlockCipher)">
             Create a buffered block cipher without padding.
            
             @param cipher the underlying block cipher this buffering object wraps.
             false otherwise.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.BufferedBlockCipher.Init(System.Boolean,NBitcoin.BouncyCastle.Crypto.ICipherParameters)">
             initialise the cipher.
            
             @param forEncryption if true the cipher is initialised for
              encryption, if false for decryption.
             @param param the key and other data required by the cipher.
             @exception ArgumentException if the parameters argument is
             inappropriate.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.BufferedBlockCipher.GetBlockSize">
             return the blocksize for the underlying cipher.
            
             @return the blocksize for the underlying cipher.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.BufferedBlockCipher.GetUpdateOutputSize(System.Int32)">
             return the size of the output buffer required for an update
             an input of len bytes.
            
             @param len the length of the input.
             @return the space required to accommodate a call to update
             with len bytes of input.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.BufferedBlockCipher.GetOutputSize(System.Int32)">
             return the size of the output buffer required for an update plus a
             doFinal with an input of len bytes.
            
             @param len the length of the input.
             @return the space required to accommodate a call to update and doFinal
             with len bytes of input.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.BufferedBlockCipher.ProcessByte(System.Byte,System.Byte[],System.Int32)">
             process a single byte, producing an output block if necessary.
            
             @param in the input byte.
             @param out the space for any output that might be produced.
             @param outOff the offset from which the output will be copied.
             @return the number of output bytes copied to out.
             @exception DataLengthException if there isn't enough space in out.
             @exception InvalidOperationException if the cipher isn't initialised.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.BufferedBlockCipher.ProcessBytes(System.Byte[],System.Int32,System.Int32,System.Byte[],System.Int32)">
             process an array of bytes, producing output if necessary.
            
             @param in the input byte array.
             @param inOff the offset at which the input data starts.
             @param len the number of bytes to be copied out of the input array.
             @param out the space for any output that might be produced.
             @param outOff the offset from which the output will be copied.
             @return the number of output bytes copied to out.
             @exception DataLengthException if there isn't enough space in out.
             @exception InvalidOperationException if the cipher isn't initialised.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.BufferedBlockCipher.DoFinal(System.Byte[],System.Int32)">
             Process the last block in the buffer.
            
             @param out the array the block currently being held is copied into.
             @param outOff the offset at which the copying starts.
             @return the number of output bytes copied to out.
             @exception DataLengthException if there is insufficient space in out for
             the output, or the input is not block size aligned and should be.
             @exception InvalidOperationException if the underlying cipher is not
             initialised.
             @exception InvalidCipherTextException if padding is expected and not found.
             @exception DataLengthException if the input is not block size
             aligned.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.BufferedBlockCipher.Reset">
            Reset the buffer and cipher. After resetting the object is in the same
            state as it was after the last init (if there was one).
        </member>
        <member name="T:NBitcoin.BouncyCastle.Crypto.DataLengthException">
            this exception is thrown if a buffer that is meant to have output
            copied into it turns out to be too short, or if we've been given
            insufficient input. In general this exception will Get thrown rather
            than an ArrayOutOfBounds exception.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.DataLengthException.#ctor">
            base constructor.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.DataLengthException.#ctor(System.String)">
             create a DataLengthException with the given message.
            
             @param message the message to be carried with the exception.
        </member>
        <member name="T:NBitcoin.BouncyCastle.Crypto.Digests.GeneralDigest">
            base implementation of MD4 family style digest as outlined in
            "Handbook of Applied Cryptography", pages 344 - 347.
        </member>
        <member name="T:NBitcoin.BouncyCastle.Crypto.Digests.LongDigest">
            Base class for SHA-384 and SHA-512.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.Digests.LongDigest.#ctor">
            Constructor for variable length word
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.Digests.LongDigest.#ctor(NBitcoin.BouncyCastle.Crypto.Digests.LongDigest)">
            Copy constructor.  We are using copy constructors in place
            of the object.Clone() interface as this interface is not
            supported by J2ME.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.Digests.LongDigest.AdjustByteCounts">
            adjust the byte counts so that byteCount2 represents the
            upper long (less 3 bits) word of the byte count.
        </member>
        <member name="T:NBitcoin.BouncyCastle.Crypto.Digests.RipeMD160Digest">
            implementation of RipeMD see,
            http://www.esat.kuleuven.ac.be/~bosselae/ripemd160.html
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.Digests.RipeMD160Digest.#ctor">
            Standard constructor
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.Digests.RipeMD160Digest.#ctor(NBitcoin.BouncyCastle.Crypto.Digests.RipeMD160Digest)">
            Copy constructor.  This will copy the state of the provided
            message digest.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.Digests.RipeMD160Digest.Reset">
            reset the chaining variables to the IV values.
        </member>
        <member name="T:NBitcoin.BouncyCastle.Crypto.Digests.Sha1Digest">
             implementation of SHA-1 as outlined in "Handbook of Applied Cryptography", pages 346 - 349.
            
             It is interesting to ponder why the, apart from the extra IV, the other difference here from MD5
             is the "endianness" of the word processing!
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.Digests.Sha1Digest.#ctor(NBitcoin.BouncyCastle.Crypto.Digests.Sha1Digest)">
            Copy constructor.  This will copy the state of the provided
            message digest.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.Digests.Sha1Digest.Reset">
            reset the chaining variables
        </member>
        <member name="T:NBitcoin.BouncyCastle.Crypto.Digests.Sha224Digest">
            SHA-224 as described in RFC 3874
            <pre>
                    block  word  digest
            SHA-1   512    32    160
            SHA-224 512    32    224
            SHA-256 512    32    256
            SHA-384 1024   64    384
            SHA-512 1024   64    512
            </pre>
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.Digests.Sha224Digest.#ctor">
            Standard constructor
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.Digests.Sha224Digest.#ctor(NBitcoin.BouncyCastle.Crypto.Digests.Sha224Digest)">
            Copy constructor.  This will copy the state of the provided
            message digest.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.Digests.Sha224Digest.Reset">
            reset the chaining variables
        </member>
        <member name="T:NBitcoin.BouncyCastle.Crypto.Digests.Sha256Digest">
             Draft FIPS 180-2 implementation of SHA-256. <b>Note:</b> As this is
             based on a draft this implementation is subject to change.
            
             <pre>
                     block  word  digest
             SHA-1   512    32    160
             SHA-256 512    32    256
             SHA-384 1024   64    384
             SHA-512 1024   64    512
             </pre>
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.Digests.Sha256Digest.#ctor(NBitcoin.BouncyCastle.Crypto.Digests.Sha256Digest)">
            Copy constructor.  This will copy the state of the provided
            message digest.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.Digests.Sha256Digest.Reset">
            reset the chaining variables
        </member>
        <member name="T:NBitcoin.BouncyCastle.Crypto.Digests.Sha384Digest">
             Draft FIPS 180-2 implementation of SHA-384. <b>Note:</b> As this is
             based on a draft this implementation is subject to change.
            
             <pre>
                     block  word  digest
             SHA-1   512    32    160
             SHA-256 512    32    256
             SHA-384 1024   64    384
             SHA-512 1024   64    512
             </pre>
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.Digests.Sha384Digest.#ctor(NBitcoin.BouncyCastle.Crypto.Digests.Sha384Digest)">
            Copy constructor.  This will copy the state of the provided
            message digest.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.Digests.Sha384Digest.Reset">
            reset the chaining variables
        </member>
        <member name="T:NBitcoin.BouncyCastle.Crypto.Digests.Sha512Digest">
             Draft FIPS 180-2 implementation of SHA-512. <b>Note:</b> As this is
             based on a draft this implementation is subject to change.
            
             <pre>
                     block  word  digest
             SHA-1   512    32    160
             SHA-256 512    32    256
             SHA-384 1024   64    384
             SHA-512 1024   64    512
             </pre>
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.Digests.Sha512Digest.#ctor(NBitcoin.BouncyCastle.Crypto.Digests.Sha512Digest)">
            Copy constructor.  This will copy the state of the provided
            message digest.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.Digests.Sha512Digest.Reset">
            reset the chaining variables
        </member>
        <member name="T:NBitcoin.BouncyCastle.Crypto.Engines.AesEngine">
             an implementation of the AES (Rijndael), from FIPS-197.
             <p>
             For further details see: <a href="http://csrc.nist.gov/encryption/aes/">http://csrc.nist.gov/encryption/aes/</a>.
            
             This implementation is based on optimizations from Dr. Brian Gladman's paper and C code at
             <a href="http://fp.gladman.plus.com/cryptography_technology/rijndael/">http://fp.gladman.plus.com/cryptography_technology/rijndael/</a>
            
             There are three levels of tradeoff of speed vs memory
             Because java has no preprocessor, they are written as three separate classes from which to choose
            
             The fastest uses 8Kbytes of static tables to precompute round calculations, 4 256 word tables for encryption
             and 4 for decryption.
            
             The middle performance version uses only one 256 word table for each, for a total of 2Kbytes,
             adding 12 rotate operations per round to compute the values contained in the other tables from
             the contents of the first.
            
             The slowest version uses no static tables at all and computes the values in each round.
             </p>
             <p>
             This file contains the middle performance version with 2Kbytes of static tables for round precomputation.
             </p>
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.Engines.AesEngine.GenerateWorkingKey(System.Byte[],System.Boolean)">
            Calculate the necessary round keys
            The number of calculations depends on key size and block size
            AES specified a fixed block size of 128 bits and key sizes 128/192/256 bits
            This code is written assuming those are the only possible values
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.Engines.AesEngine.#ctor">
            default constructor - 128 bit block size.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.Engines.AesEngine.Init(System.Boolean,NBitcoin.BouncyCastle.Crypto.ICipherParameters)">
             initialise an AES cipher.
            
             @param forEncryption whether or not we are for encryption.
             @param parameters the parameters required to set up the cipher.
             @exception ArgumentException if the parameters argument is
             inappropriate.
        </member>
        <member name="T:NBitcoin.BouncyCastle.Crypto.Engines.AesFastEngine">
             an implementation of the AES (Rijndael)), from FIPS-197.
             <p>
             For further details see: <a href="http://csrc.nist.gov/encryption/aes/">http://csrc.nist.gov/encryption/aes/</a>.
            
             This implementation is based on optimizations from Dr. Brian Gladman's paper and C code at
             <a href="http://fp.gladman.plus.com/cryptography_technology/rijndael/">http://fp.gladman.plus.com/cryptography_technology/rijndael/</a>
            
             There are three levels of tradeoff of speed vs memory
             Because java has no preprocessor), they are written as three separate classes from which to choose
            
             The fastest uses 8Kbytes of static tables to precompute round calculations), 4 256 word tables for encryption
             and 4 for decryption.
            
             The middle performance version uses only one 256 word table for each), for a total of 2Kbytes),
             adding 12 rotate operations per round to compute the values contained in the other tables from
             the contents of the first
            
             The slowest version uses no static tables at all and computes the values in each round
             </p>
             <p>
             This file contains the fast version with 8Kbytes of static tables for round precomputation
             </p>
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.Engines.AesFastEngine.GenerateWorkingKey(System.Byte[],System.Boolean)">
            Calculate the necessary round keys
            The number of calculations depends on key size and block size
            AES specified a fixed block size of 128 bits and key sizes 128/192/256 bits
            This code is written assuming those are the only possible values
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.Engines.AesFastEngine.#ctor">
            default constructor - 128 bit block size.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.Engines.AesFastEngine.Init(System.Boolean,NBitcoin.BouncyCastle.Crypto.ICipherParameters)">
             initialise an AES cipher.
            
             @param forEncryption whether or not we are for encryption.
             @param parameters the parameters required to set up the cipher.
             @exception ArgumentException if the parameters argument is
             inappropriate.
        </member>
        <member name="T:NBitcoin.BouncyCastle.Crypto.IAsymmetricBlockCipher">
            <remarks>Base interface for a public/private key block cipher.</remarks>
        </member>
        <member name="P:NBitcoin.BouncyCastle.Crypto.IAsymmetricBlockCipher.AlgorithmName">
            <summary>The name of the algorithm this cipher implements.</summary>
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.IAsymmetricBlockCipher.Init(System.Boolean,NBitcoin.BouncyCastle.Crypto.ICipherParameters)">
            <summary>Initialise the cipher.</summary>
            <param name="forEncryption">Initialise for encryption if true, for decryption if false.</param>
            <param name="parameters">The key or other data required by the cipher.</param>
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.IAsymmetricBlockCipher.GetInputBlockSize">
            <returns>The maximum size, in bytes, an input block may be.</returns>
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.IAsymmetricBlockCipher.GetOutputBlockSize">
            <returns>The maximum size, in bytes, an output block will be.</returns>
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.IAsymmetricBlockCipher.ProcessBlock(System.Byte[],System.Int32,System.Int32)">
            <summary>Process a block.</summary>
            <param name="inBuf">The input buffer.</param>
            <param name="inOff">The offset into <paramref>inBuf</paramref> that the input block begins.</param>
            <param name="inLen">The length of the input block.</param>
            <exception cref="T:NBitcoin.BouncyCastle.Crypto.InvalidCipherTextException">Input decrypts improperly.</exception>
            <exception cref="T:NBitcoin.BouncyCastle.Crypto.DataLengthException">Input is too large for the cipher.</exception>
        </member>
        <member name="T:NBitcoin.BouncyCastle.Crypto.IBlockCipher">
            <remarks>Base interface for a symmetric key block cipher.</remarks>
        </member>
        <member name="P:NBitcoin.BouncyCastle.Crypto.IBlockCipher.AlgorithmName">
            <summary>The name of the algorithm this cipher implements.</summary>
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.IBlockCipher.Init(System.Boolean,NBitcoin.BouncyCastle.Crypto.ICipherParameters)">
            <summary>Initialise the cipher.</summary>
            <param name="forEncryption">Initialise for encryption if true, for decryption if false.</param>
            <param name="parameters">The key or other data required by the cipher.</param>
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.IBlockCipher.GetBlockSize">
            <returns>The block size for this cipher, in bytes.</returns>
        </member>
        <member name="P:NBitcoin.BouncyCastle.Crypto.IBlockCipher.IsPartialBlockOkay">
            <summary>Indicates whether this cipher can handle partial blocks.</summary>
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.IBlockCipher.ProcessBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            <summary>Process a block.</summary>
            <param name="inBuf">The input buffer.</param>
            <param name="inOff">The offset into <paramref>inBuf</paramref> that the input block begins.</param>
            <param name="outBuf">The output buffer.</param>
            <param name="outOff">The offset into <paramref>outBuf</paramref> to write the output block.</param>
            <exception cref="T:NBitcoin.BouncyCastle.Crypto.DataLengthException">If input block is wrong size, or outBuf too small.</exception>
            <returns>The number of bytes processed and produced.</returns>
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.IBlockCipher.Reset">
            <summary>
            Reset the cipher to the same state as it was after the last init (if there was one).
            </summary>
        </member>
        <member name="T:NBitcoin.BouncyCastle.Crypto.IBufferedCipher">
            <remarks>Block cipher engines are expected to conform to this interface.</remarks>
        </member>
        <member name="P:NBitcoin.BouncyCastle.Crypto.IBufferedCipher.AlgorithmName">
            <summary>The name of the algorithm this cipher implements.</summary>
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.IBufferedCipher.Init(System.Boolean,NBitcoin.BouncyCastle.Crypto.ICipherParameters)">
            <summary>Initialise the cipher.</summary>
            <param name="forEncryption">If true the cipher is initialised for encryption,
            if false for decryption.</param>
            <param name="parameters">The key and other data required by the cipher.</param>
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.IBufferedCipher.Reset">
            <summary>
            Reset the cipher. After resetting the cipher is in the same state
            as it was after the last init (if there was one).
            </summary>
        </member>
        <member name="T:NBitcoin.BouncyCastle.Crypto.ICipherParameters">
            all parameter classes implement this.
        </member>
        <member name="T:NBitcoin.BouncyCastle.Crypto.IDigest">
            interface that a message digest conforms to.
        </member>
        <member name="P:NBitcoin.BouncyCastle.Crypto.IDigest.AlgorithmName">
             return the algorithm name
            
             @return the algorithm name
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.IDigest.GetDigestSize">
             return the size, in bytes, of the digest produced by this message digest.
            
             @return the size, in bytes, of the digest produced by this message digest.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.IDigest.GetByteLength">
             return the size, in bytes, of the internal buffer used by this digest.
            
             @return the size, in bytes, of the internal buffer used by this digest.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.IDigest.Update(System.Byte)">
             update the message digest with a single byte.
            
             @param inByte the input byte to be entered.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.IDigest.BlockUpdate(System.Byte[],System.Int32,System.Int32)">
             update the message digest with a block of bytes.
            
             @param input the byte array containing the data.
             @param inOff the offset into the byte array where the data starts.
             @param len the length of the data.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.IDigest.DoFinal(System.Byte[],System.Int32)">
             Close the digest, producing the final digest value. The doFinal
             call leaves the digest reset.
            
             @param output the array the digest is to be copied into.
             @param outOff the offset into the out array the digest is to start at.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.IDigest.Reset">
            reset the digest back to it's initial state.
        </member>
        <member name="T:NBitcoin.BouncyCastle.Crypto.IDsa">
            interface for classes implementing the Digital Signature Algorithm
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.IDsa.Init(System.Boolean,NBitcoin.BouncyCastle.Crypto.ICipherParameters)">
             initialise the signer for signature generation or signature
             verification.
            
             @param forSigning true if we are generating a signature, false
             otherwise.
             @param param key parameters for signature generation.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.IDsa.GenerateSignature(System.Byte[])">
             sign the passed in message (usually the output of a hash function).
            
             @param message the message to be signed.
             @return two big integers representing the r and s values respectively.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.IDsa.VerifySignature(System.Byte[],NBitcoin.BouncyCastle.Math.BigInteger,NBitcoin.BouncyCastle.Math.BigInteger)">
             verify the message message against the signature values r and s.
            
             @param message the message that was supposed to have been signed.
             @param r the r signature value.
             @param s the s signature value.
        </member>
        <member name="T:NBitcoin.BouncyCastle.Crypto.IMac">
            The base interface for implementations of message authentication codes (MACs).
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.IMac.Init(NBitcoin.BouncyCastle.Crypto.ICipherParameters)">
             Initialise the MAC.
            
             @param param the key and other data required by the MAC.
             @exception ArgumentException if the parameters argument is
             inappropriate.
        </member>
        <member name="P:NBitcoin.BouncyCastle.Crypto.IMac.AlgorithmName">
             Return the name of the algorithm the MAC implements.
            
             @return the name of the algorithm the MAC implements.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.IMac.GetMacSize">
             Return the block size for this MAC (in bytes).
            
             @return the block size for this MAC in bytes.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.IMac.Update(System.Byte)">
             add a single byte to the mac for processing.
            
             @param in the byte to be processed.
             @exception InvalidOperationException if the MAC is not initialised.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.IMac.BlockUpdate(System.Byte[],System.Int32,System.Int32)">
            @param in the array containing the input.
            @param inOff the index in the array the data begins at.
            @param len the length of the input starting at inOff.
            @exception InvalidOperationException if the MAC is not initialised.
            @exception DataLengthException if there isn't enough data in in.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.IMac.DoFinal(System.Byte[],System.Int32)">
            Compute the final stage of the MAC writing the output to the out
            parameter.
            <p>
            doFinal leaves the MAC in the same state it was after the last init.
            </p>
            @param out the array the MAC is to be output to.
            @param outOff the offset into the out buffer the output is to start at.
            @exception DataLengthException if there isn't enough space in out.
            @exception InvalidOperationException if the MAC is not initialised.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.IMac.Reset">
            Reset the MAC. At the end of resetting the MAC should be in the
            in the same state it was after the last init (if there was one).
        </member>
        <member name="T:NBitcoin.BouncyCastle.Crypto.InvalidCipherTextException">
            this exception is thrown whenever we find something we don't expect in a
            message.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.InvalidCipherTextException.#ctor">
            base constructor.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.InvalidCipherTextException.#ctor(System.String)">
             create a InvalidCipherTextException with the given message.
            
             @param message the message to be carried with the exception.
        </member>
        <member name="P:NBitcoin.BouncyCastle.Crypto.ISigner.AlgorithmName">
             Return the name of the algorithm the signer implements.
            
             @return the name of the algorithm the signer implements.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.ISigner.Init(System.Boolean,NBitcoin.BouncyCastle.Crypto.ICipherParameters)">
             Initialise the signer for signing or verification.
            
             @param forSigning true if for signing, false otherwise
             @param param necessary parameters.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.ISigner.Update(System.Byte)">
            update the internal digest with the byte b
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.ISigner.BlockUpdate(System.Byte[],System.Int32,System.Int32)">
            update the internal digest with the byte array in
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.ISigner.GenerateSignature">
            Generate a signature for the message we've been loaded with using
            the key we were initialised with.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.ISigner.VerifySignature(System.Byte[])">
            return true if the internal state represents the signature described
            in the passed in array.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.ISigner.Reset">
            reset the internal state
        </member>
        <member name="T:NBitcoin.BouncyCastle.Crypto.Macs.HMac">
             HMAC implementation based on RFC2104
            
             H(K XOR opad, H(K XOR ipad, text))
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.Macs.HMac.Reset">
            Reset the mac generator.
        </member>
        <member name="T:NBitcoin.BouncyCastle.Crypto.Paddings.IBlockCipherPadding">
            Block cipher padders are expected to conform to this interface
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.Paddings.IBlockCipherPadding.Init(NBitcoin.BouncyCastle.Security.SecureRandom)">
             Initialise the padder.
            
             @param param parameters, if any required.
        </member>
        <member name="P:NBitcoin.BouncyCastle.Crypto.Paddings.IBlockCipherPadding.PaddingName">
             Return the name of the algorithm the cipher implements.
            
             @return the name of the algorithm the cipher implements.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.Paddings.IBlockCipherPadding.AddPadding(System.Byte[],System.Int32)">
            add the pad bytes to the passed in block, returning the
            number of bytes added.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.Paddings.IBlockCipherPadding.PadCount(System.Byte[])">
            return the number of pad bytes present in the block.
            @exception InvalidCipherTextException if the padding is badly formed
            or invalid.
        </member>
        <member name="T:NBitcoin.BouncyCastle.Crypto.Paddings.PaddedBufferedBlockCipher">
            A wrapper class that allows block ciphers to be used to process data in
            a piecemeal fashion with padding. The PaddedBufferedBlockCipher
            outputs a block only when the buffer is full and more data is being added,
            or on a doFinal (unless the current block in the buffer is a pad block).
            The default padding mechanism used is the one outlined in Pkcs5/Pkcs7.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.Paddings.PaddedBufferedBlockCipher.#ctor(NBitcoin.BouncyCastle.Crypto.IBlockCipher,NBitcoin.BouncyCastle.Crypto.Paddings.IBlockCipherPadding)">
             Create a buffered block cipher with the desired padding.
            
             @param cipher the underlying block cipher this buffering object wraps.
             @param padding the padding type.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.Paddings.PaddedBufferedBlockCipher.#ctor(NBitcoin.BouncyCastle.Crypto.IBlockCipher)">
             Create a buffered block cipher Pkcs7 padding
            
             @param cipher the underlying block cipher this buffering object wraps.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.Paddings.PaddedBufferedBlockCipher.Init(System.Boolean,NBitcoin.BouncyCastle.Crypto.ICipherParameters)">
             initialise the cipher.
            
             @param forEncryption if true the cipher is initialised for
              encryption, if false for decryption.
             @param param the key and other data required by the cipher.
             @exception ArgumentException if the parameters argument is
             inappropriate.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.Paddings.PaddedBufferedBlockCipher.GetOutputSize(System.Int32)">
             return the minimum size of the output buffer required for an update
             plus a doFinal with an input of len bytes.
            
             @param len the length of the input.
             @return the space required to accommodate a call to update and doFinal
             with len bytes of input.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.Paddings.PaddedBufferedBlockCipher.GetUpdateOutputSize(System.Int32)">
             return the size of the output buffer required for an update
             an input of len bytes.
            
             @param len the length of the input.
             @return the space required to accommodate a call to update
             with len bytes of input.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.Paddings.PaddedBufferedBlockCipher.ProcessByte(System.Byte,System.Byte[],System.Int32)">
             process a single byte, producing an output block if necessary.
            
             @param in the input byte.
             @param out the space for any output that might be produced.
             @param outOff the offset from which the output will be copied.
             @return the number of output bytes copied to out.
             @exception DataLengthException if there isn't enough space in out.
             @exception InvalidOperationException if the cipher isn't initialised.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.Paddings.PaddedBufferedBlockCipher.ProcessBytes(System.Byte[],System.Int32,System.Int32,System.Byte[],System.Int32)">
             process an array of bytes, producing output if necessary.
            
             @param in the input byte array.
             @param inOff the offset at which the input data starts.
             @param len the number of bytes to be copied out of the input array.
             @param out the space for any output that might be produced.
             @param outOff the offset from which the output will be copied.
             @return the number of output bytes copied to out.
             @exception DataLengthException if there isn't enough space in out.
             @exception InvalidOperationException if the cipher isn't initialised.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.Paddings.PaddedBufferedBlockCipher.DoFinal(System.Byte[],System.Int32)">
             Process the last block in the buffer. If the buffer is currently
             full and padding needs to be added a call to doFinal will produce
             2 * GetBlockSize() bytes.
            
             @param out the array the block currently being held is copied into.
             @param outOff the offset at which the copying starts.
             @return the number of output bytes copied to out.
             @exception DataLengthException if there is insufficient space in out for
             the output or we are decrypting and the input is not block size aligned.
             @exception InvalidOperationException if the underlying cipher is not
             initialised.
             @exception InvalidCipherTextException if padding is expected and not found.
        </member>
        <member name="T:NBitcoin.BouncyCastle.Crypto.Paddings.Pkcs7Padding">
            A padder that adds Pkcs7/Pkcs5 padding to a block.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.Paddings.Pkcs7Padding.Init(NBitcoin.BouncyCastle.Security.SecureRandom)">
             Initialise the padder.
            
             @param random - a SecureRandom if available.
        </member>
        <member name="P:NBitcoin.BouncyCastle.Crypto.Paddings.Pkcs7Padding.PaddingName">
             Return the name of the algorithm the cipher implements.
            
             @return the name of the algorithm the cipher implements.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.Paddings.Pkcs7Padding.AddPadding(System.Byte[],System.Int32)">
            add the pad bytes to the passed in block, returning the
            number of bytes added.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.Paddings.Pkcs7Padding.PadCount(System.Byte[])">
            return the number of pad bytes present in the block.
        </member>
        <member name="T:NBitcoin.BouncyCastle.Crypto.Signers.ECDsaSigner">
            EC-DSA as described in X9.62
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.Signers.ECDsaSigner.#ctor">
            Default configuration, random K values.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.Signers.ECDsaSigner.#ctor(NBitcoin.BouncyCastle.Crypto.Signers.IDsaKCalculator)">
             Configuration with an alternate, possibly deterministic calculator of K.
            
             @param kCalculator a K value calculator.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.Signers.ECDsaSigner.GenerateSignature(System.Byte[])">
             Generate a signature for the given message using the key we were
             initialised with. For conventional DSA the message should be a SHA-1
             hash of the message of interest.
            
             @param message the message that will be verified later.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.Signers.ECDsaSigner.VerifySignature(System.Byte[],NBitcoin.BouncyCastle.Math.BigInteger,NBitcoin.BouncyCastle.Math.BigInteger)">
            return true if the value r and s represent a DSA signature for
            the passed in message (for standard DSA the message should be
            a SHA-1 hash of the real message to be verified).
        </member>
        <member name="T:NBitcoin.BouncyCastle.Crypto.Signers.HMacDsaKCalculator">
            A deterministic K calculator based on the algorithm in section 3.2 of RFC 6979.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.Signers.HMacDsaKCalculator.#ctor(NBitcoin.BouncyCastle.Crypto.IDigest)">
             Base constructor.
            
             @param digest digest to build the HMAC on.
        </member>
        <member name="T:NBitcoin.BouncyCastle.Crypto.Signers.IDsaKCalculator">
            Interface define calculators of K values for DSA/ECDSA.
        </member>
        <member name="P:NBitcoin.BouncyCastle.Crypto.Signers.IDsaKCalculator.IsDeterministic">
             Return true if this calculator is deterministic, false otherwise.
            
             @return true if deterministic, otherwise false.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.Signers.IDsaKCalculator.Init(NBitcoin.BouncyCastle.Math.BigInteger,NBitcoin.BouncyCastle.Security.SecureRandom)">
             Non-deterministic initialiser.
            
             @param n the order of the DSA group.
             @param random a source of randomness.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.Signers.IDsaKCalculator.Init(NBitcoin.BouncyCastle.Math.BigInteger,NBitcoin.BouncyCastle.Math.BigInteger,System.Byte[])">
             Deterministic initialiser.
            
             @param n the order of the DSA group.
             @param d the DSA private value.
             @param message the message being signed.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Crypto.Signers.IDsaKCalculator.NextK">
             Return the next valid value of K.
            
             @return a K value.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Math.BigInteger.AddMagnitudes(System.Int32[],System.Int32[])">
            return a = a + b - b preserved.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Math.BigInteger.CompareTo(System.Int32,System.Int32[],System.Int32,System.Int32[])">
            unsigned comparison on two arrays - note the arrays may
            start with leading zeros.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Math.BigInteger.Divide(System.Int32[],System.Int32[])">
            return z = x / y - done in place (z value preserved, x contains the
            remainder)
        </member>
        <member name="M:NBitcoin.BouncyCastle.Math.BigInteger.IsProbablePrime(System.Int32)">
            return whether or not a BigInteger is probably prime with a
            probability of 1 - (1/2)**certainty.
            <p>From Knuth Vol 2, pg 395.</p>
        </member>
        <member name="M:NBitcoin.BouncyCastle.Math.BigInteger.ExtEuclid(NBitcoin.BouncyCastle.Math.BigInteger,NBitcoin.BouncyCastle.Math.BigInteger,NBitcoin.BouncyCastle.Math.BigInteger@)">
             Calculate the numbers u1, u2, and u3 such that:
            
             u1 * a + u2 * b = u3
            
             where u3 is the greatest common divider of a and b.
             a and b using the extended Euclid algorithm (refer p. 323
             of The Art of Computer Programming vol 2, 2nd ed).
             This also seems to have the side effect of calculating
             some form of multiplicative inverse.
            
             @param a    First number to calculate gcd for
             @param b    Second number to calculate gcd for
             @param u1Out      the return object for the u1 value
             @return     The greatest common divisor of a and b
        </member>
        <member name="M:NBitcoin.BouncyCastle.Math.BigInteger.Square(System.Int32[],System.Int32[])">
            return w with w = x * x - w is assumed to have enough space.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Math.BigInteger.Multiply(System.Int32[],System.Int32[],System.Int32[])">
            return x with x = y * z - x is assumed to have enough space.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Math.BigInteger.GetMQuote">
            Calculate mQuote = -m^(-1) mod b with b = 2^32 (32 = word size)
        </member>
        <member name="M:NBitcoin.BouncyCastle.Math.BigInteger.MultiplyMonty(System.Int32[],System.Int32[],System.Int32[],System.Int32[],System.UInt32,System.Boolean)">
            Montgomery multiplication: a = x * y * R^(-1) mod m
            <br/>
            Based algorithm 14.36 of Handbook of Applied Cryptography.
            <br/>
            <li> m, x, y should have length n </li>
            <li> a should have length (n + 1) </li>
            <li> b = 2^32, R = b^n </li>
            <br/>
            The result is put in x
            <br/>
            NOTE: the indices of x, y, m, a different in HAC and in Java
        </member>
        <member name="M:NBitcoin.BouncyCastle.Math.BigInteger.Remainder(System.Int32[],System.Int32[])">
            return x = x % y - done in place (y value preserved)
        </member>
        <member name="M:NBitcoin.BouncyCastle.Math.BigInteger.ShiftLeft(System.Int32[],System.Int32)">
            do a left shift - this returns a new array.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Math.BigInteger.ShiftRightInPlace(System.Int32,System.Int32[],System.Int32)">
            do a right shift - this does it in place.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Math.BigInteger.ShiftRightOneInPlace(System.Int32,System.Int32[])">
            do a right shift by one - this does it in place.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Math.BigInteger.Subtract(System.Int32,System.Int32[],System.Int32,System.Int32[])">
            returns x = x - y - we assume x is >= y
        </member>
        <member name="T:NBitcoin.BouncyCastle.Math.EC.Abc.SimpleBigDecimal">
            Class representing a simple version of a big decimal. A
            <code>SimpleBigDecimal</code> is basically a
            {@link java.math.BigInteger BigInteger} with a few digits on the right of
            the decimal point. The number of (binary) digits on the right of the decimal
            point is called the <code>scale</code> of the <code>SimpleBigDecimal</code>.
            Unlike in {@link java.math.BigDecimal BigDecimal}, the scale is not adjusted
            automatically, but must be set manually. All <code>SimpleBigDecimal</code>s
            taking part in the same arithmetic operation must have equal scale. The
            result of a multiplication of two <code>SimpleBigDecimal</code>s returns a
            <code>SimpleBigDecimal</code> with double scale.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Math.EC.Abc.SimpleBigDecimal.GetInstance(NBitcoin.BouncyCastle.Math.BigInteger,System.Int32)">
            Returns a <code>SimpleBigDecimal</code> representing the same numerical
            value as <code>value</code>.
            @param value The value of the <code>SimpleBigDecimal</code> to be
            created. 
            @param scale The scale of the <code>SimpleBigDecimal</code> to be
            created. 
            @return The such created <code>SimpleBigDecimal</code>.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Math.EC.Abc.SimpleBigDecimal.#ctor(NBitcoin.BouncyCastle.Math.BigInteger,System.Int32)">
            Constructor for <code>SimpleBigDecimal</code>. The value of the
            constructed <code>SimpleBigDecimal</code> Equals <code>bigInt / 
            2<sup>scale</sup></code>.
            @param bigInt The <code>bigInt</code> value parameter.
            @param scale The scale of the constructed <code>SimpleBigDecimal</code>.
        </member>
        <member name="T:NBitcoin.BouncyCastle.Math.EC.Abc.Tnaf">
            Class holding methods for point multiplication based on the window
            &#964;-adic nonadjacent form (WTNAF). The algorithms are based on the
            paper "Improved Algorithms for Arithmetic on Anomalous Binary Curves"
            by Jerome A. Solinas. The paper first appeared in the Proceedings of
            Crypto 1997.
        </member>
        <member name="F:NBitcoin.BouncyCastle.Math.EC.Abc.Tnaf.Width">
            The window width of WTNAF. The standard value of 4 is slightly less
            than optimal for running time, but keeps space requirements for
            precomputation low. For typical curves, a value of 5 or 6 results in
            a better running time. When changing this value, the
            <code>&#945;<sub>u</sub></code>'s must be computed differently, see
            e.g. "Guide to Elliptic Curve Cryptography", Darrel Hankerson,
            Alfred Menezes, Scott Vanstone, Springer-Verlag New York Inc., 2004,
            p. 121-122
        </member>
        <member name="F:NBitcoin.BouncyCastle.Math.EC.Abc.Tnaf.Pow2Width">
            2<sup>4</sup>
        </member>
        <member name="F:NBitcoin.BouncyCastle.Math.EC.Abc.Tnaf.Alpha0">
            The <code>&#945;<sub>u</sub></code>'s for <code>a=0</code> as an array
            of <code>ZTauElement</code>s.
        </member>
        <member name="F:NBitcoin.BouncyCastle.Math.EC.Abc.Tnaf.Alpha0Tnaf">
            The <code>&#945;<sub>u</sub></code>'s for <code>a=0</code> as an array
            of TNAFs.
        </member>
        <member name="F:NBitcoin.BouncyCastle.Math.EC.Abc.Tnaf.Alpha1">
            The <code>&#945;<sub>u</sub></code>'s for <code>a=1</code> as an array
            of <code>ZTauElement</code>s.
        </member>
        <member name="F:NBitcoin.BouncyCastle.Math.EC.Abc.Tnaf.Alpha1Tnaf">
            The <code>&#945;<sub>u</sub></code>'s for <code>a=1</code> as an array
            of TNAFs.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Math.EC.Abc.Tnaf.Norm(System.SByte,NBitcoin.BouncyCastle.Math.EC.Abc.ZTauElement)">
            Computes the norm of an element <code>&#955;</code> of
            <code><b>Z</b>[&#964;]</code>.
            @param mu The parameter <code>&#956;</code> of the elliptic curve.
            @param lambda The element <code>&#955;</code> of
            <code><b>Z</b>[&#964;]</code>.
            @return The norm of <code>&#955;</code>.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Math.EC.Abc.Tnaf.Norm(System.SByte,NBitcoin.BouncyCastle.Math.EC.Abc.SimpleBigDecimal,NBitcoin.BouncyCastle.Math.EC.Abc.SimpleBigDecimal)">
            Computes the norm of an element <code>&#955;</code> of
            <code><b>R</b>[&#964;]</code>, where <code>&#955; = u + v&#964;</code>
            and <code>u</code> and <code>u</code> are real numbers (elements of
            <code><b>R</b></code>). 
            @param mu The parameter <code>&#956;</code> of the elliptic curve.
            @param u The real part of the element <code>&#955;</code> of
            <code><b>R</b>[&#964;]</code>.
            @param v The <code>&#964;</code>-adic part of the element
            <code>&#955;</code> of <code><b>R</b>[&#964;]</code>.
            @return The norm of <code>&#955;</code>.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Math.EC.Abc.Tnaf.Round(NBitcoin.BouncyCastle.Math.EC.Abc.SimpleBigDecimal,NBitcoin.BouncyCastle.Math.EC.Abc.SimpleBigDecimal,System.SByte)">
            Rounds an element <code>&#955;</code> of <code><b>R</b>[&#964;]</code>
            to an element of <code><b>Z</b>[&#964;]</code>, such that their difference
            has minimal norm. <code>&#955;</code> is given as
            <code>&#955; = &#955;<sub>0</sub> + &#955;<sub>1</sub>&#964;</code>.
            @param lambda0 The component <code>&#955;<sub>0</sub></code>.
            @param lambda1 The component <code>&#955;<sub>1</sub></code>.
            @param mu The parameter <code>&#956;</code> of the elliptic curve. Must
            equal 1 or -1.
            @return The rounded element of <code><b>Z</b>[&#964;]</code>.
            @throws ArgumentException if <code>lambda0</code> and
            <code>lambda1</code> do not have same scale.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Math.EC.Abc.Tnaf.ApproximateDivisionByN(NBitcoin.BouncyCastle.Math.BigInteger,NBitcoin.BouncyCastle.Math.BigInteger,NBitcoin.BouncyCastle.Math.BigInteger,System.SByte,System.Int32,System.Int32)">
            Approximate division by <code>n</code>. For an integer
            <code>k</code>, the value <code>&#955; = s k / n</code> is
            computed to <code>c</code> bits of accuracy.
            @param k The parameter <code>k</code>.
            @param s The curve parameter <code>s<sub>0</sub></code> or
            <code>s<sub>1</sub></code>.
            @param vm The Lucas Sequence element <code>V<sub>m</sub></code>.
            @param a The parameter <code>a</code> of the elliptic curve.
            @param m The bit length of the finite field
            <code><b>F</b><sub>m</sub></code>.
            @param c The number of bits of accuracy, i.e. the scale of the returned
            <code>SimpleBigDecimal</code>.
            @return The value <code>&#955; = s k / n</code> computed to
            <code>c</code> bits of accuracy.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Math.EC.Abc.Tnaf.TauAdicNaf(System.SByte,NBitcoin.BouncyCastle.Math.EC.Abc.ZTauElement)">
            Computes the <code>&#964;</code>-adic NAF (non-adjacent form) of an
            element <code>&#955;</code> of <code><b>Z</b>[&#964;]</code>.
            @param mu The parameter <code>&#956;</code> of the elliptic curve.
            @param lambda The element <code>&#955;</code> of
            <code><b>Z</b>[&#964;]</code>.
            @return The <code>&#964;</code>-adic NAF of <code>&#955;</code>.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Math.EC.Abc.Tnaf.Tau(NBitcoin.BouncyCastle.Math.EC.AbstractF2mPoint)">
            Applies the operation <code>&#964;()</code> to an
            <code>AbstractF2mPoint</code>. 
            @param p The AbstractF2mPoint to which <code>&#964;()</code> is applied.
            @return <code>&#964;(p)</code>
        </member>
        <member name="M:NBitcoin.BouncyCastle.Math.EC.Abc.Tnaf.GetMu(NBitcoin.BouncyCastle.Math.EC.AbstractF2mCurve)">
            Returns the parameter <code>&#956;</code> of the elliptic curve.
            @param curve The elliptic curve from which to obtain <code>&#956;</code>.
            The curve must be a Koblitz curve, i.e. <code>a</code> Equals
            <code>0</code> or <code>1</code> and <code>b</code> Equals
            <code>1</code>. 
            @return <code>&#956;</code> of the elliptic curve.
            @throws ArgumentException if the given ECCurve is not a Koblitz
            curve.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Math.EC.Abc.Tnaf.GetLucas(System.SByte,System.Int32,System.Boolean)">
            Calculates the Lucas Sequence elements <code>U<sub>k-1</sub></code> and
            <code>U<sub>k</sub></code> or <code>V<sub>k-1</sub></code> and
            <code>V<sub>k</sub></code>.
            @param mu The parameter <code>&#956;</code> of the elliptic curve.
            @param k The index of the second element of the Lucas Sequence to be
            returned.
            @param doV If set to true, computes <code>V<sub>k-1</sub></code> and
            <code>V<sub>k</sub></code>, otherwise <code>U<sub>k-1</sub></code> and
            <code>U<sub>k</sub></code>.
            @return An array with 2 elements, containing <code>U<sub>k-1</sub></code>
            and <code>U<sub>k</sub></code> or <code>V<sub>k-1</sub></code>
            and <code>V<sub>k</sub></code>.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Math.EC.Abc.Tnaf.GetTw(System.SByte,System.Int32)">
            Computes the auxiliary value <code>t<sub>w</sub></code>. If the width is
            4, then for <code>mu = 1</code>, <code>t<sub>w</sub> = 6</code> and for
            <code>mu = -1</code>, <code>t<sub>w</sub> = 10</code> 
            @param mu The parameter <code>&#956;</code> of the elliptic curve.
            @param w The window width of the WTNAF.
            @return the auxiliary value <code>t<sub>w</sub></code>
        </member>
        <member name="M:NBitcoin.BouncyCastle.Math.EC.Abc.Tnaf.GetSi(NBitcoin.BouncyCastle.Math.EC.AbstractF2mCurve)">
            Computes the auxiliary values <code>s<sub>0</sub></code> and
            <code>s<sub>1</sub></code> used for partial modular reduction. 
            @param curve The elliptic curve for which to compute
            <code>s<sub>0</sub></code> and <code>s<sub>1</sub></code>.
            @throws ArgumentException if <code>curve</code> is not a
            Koblitz curve (Anomalous Binary Curve, ABC).
        </member>
        <member name="M:NBitcoin.BouncyCastle.Math.EC.Abc.Tnaf.PartModReduction(NBitcoin.BouncyCastle.Math.BigInteger,System.Int32,System.SByte,NBitcoin.BouncyCastle.Math.BigInteger[],System.SByte,System.SByte)">
            Partial modular reduction modulo
            <code>(&#964;<sup>m</sup> - 1)/(&#964; - 1)</code>.
            @param k The integer to be reduced.
            @param m The bitlength of the underlying finite field.
            @param a The parameter <code>a</code> of the elliptic curve.
            @param s The auxiliary values <code>s<sub>0</sub></code> and
            <code>s<sub>1</sub></code>.
            @param mu The parameter &#956; of the elliptic curve.
            @param c The precision (number of bits of accuracy) of the partial
            modular reduction.
            @return <code>&#961; := k partmod (&#964;<sup>m</sup> - 1)/(&#964; - 1)</code>
        </member>
        <member name="M:NBitcoin.BouncyCastle.Math.EC.Abc.Tnaf.MultiplyRTnaf(NBitcoin.BouncyCastle.Math.EC.AbstractF2mPoint,NBitcoin.BouncyCastle.Math.BigInteger)">
            Multiplies a {@link NBitcoin.BouncyCastle.math.ec.AbstractF2mPoint AbstractF2mPoint}
            by a <code>BigInteger</code> using the reduced <code>&#964;</code>-adic
            NAF (RTNAF) method.
            @param p The AbstractF2mPoint to Multiply.
            @param k The <code>BigInteger</code> by which to Multiply <code>p</code>.
            @return <code>k * p</code>
        </member>
        <member name="M:NBitcoin.BouncyCastle.Math.EC.Abc.Tnaf.MultiplyTnaf(NBitcoin.BouncyCastle.Math.EC.AbstractF2mPoint,NBitcoin.BouncyCastle.Math.EC.Abc.ZTauElement)">
            Multiplies a {@link NBitcoin.BouncyCastle.math.ec.AbstractF2mPoint AbstractF2mPoint}
            by an element <code>&#955;</code> of <code><b>Z</b>[&#964;]</code>
            using the <code>&#964;</code>-adic NAF (TNAF) method.
            @param p The AbstractF2mPoint to Multiply.
            @param lambda The element <code>&#955;</code> of
            <code><b>Z</b>[&#964;]</code>.
            @return <code>&#955; * p</code>
        </member>
        <member name="M:NBitcoin.BouncyCastle.Math.EC.Abc.Tnaf.MultiplyFromTnaf(NBitcoin.BouncyCastle.Math.EC.AbstractF2mPoint,System.SByte[])">
            Multiplies a {@link NBitcoin.BouncyCastle.math.ec.AbstractF2mPoint AbstractF2mPoint}
            by an element <code>&#955;</code> of <code><b>Z</b>[&#964;]</code>
            using the <code>&#964;</code>-adic NAF (TNAF) method, given the TNAF
            of <code>&#955;</code>.
            @param p The AbstractF2mPoint to Multiply.
            @param u The the TNAF of <code>&#955;</code>..
            @return <code>&#955; * p</code>
        </member>
        <member name="M:NBitcoin.BouncyCastle.Math.EC.Abc.Tnaf.TauAdicWNaf(System.SByte,NBitcoin.BouncyCastle.Math.EC.Abc.ZTauElement,System.SByte,NBitcoin.BouncyCastle.Math.BigInteger,NBitcoin.BouncyCastle.Math.BigInteger,NBitcoin.BouncyCastle.Math.EC.Abc.ZTauElement[])">
            Computes the <code>[&#964;]</code>-adic window NAF of an element
            <code>&#955;</code> of <code><b>Z</b>[&#964;]</code>.
            @param mu The parameter &#956; of the elliptic curve.
            @param lambda The element <code>&#955;</code> of
            <code><b>Z</b>[&#964;]</code> of which to compute the
            <code>[&#964;]</code>-adic NAF.
            @param width The window width of the resulting WNAF.
            @param pow2w 2<sup>width</sup>.
            @param tw The auxiliary value <code>t<sub>w</sub></code>.
            @param alpha The <code>&#945;<sub>u</sub></code>'s for the window width.
            @return The <code>[&#964;]</code>-adic window NAF of
            <code>&#955;</code>.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Math.EC.Abc.Tnaf.GetPreComp(NBitcoin.BouncyCastle.Math.EC.AbstractF2mPoint,System.SByte)">
            Does the precomputation for WTNAF multiplication.
            @param p The <code>ECPoint</code> for which to do the precomputation.
            @param a The parameter <code>a</code> of the elliptic curve.
            @return The precomputation array for <code>p</code>. 
        </member>
        <member name="T:NBitcoin.BouncyCastle.Math.EC.Abc.ZTauElement">
            Class representing an element of <code><b>Z</b>[&#964;]</code>. Let
            <code>&#955;</code> be an element of <code><b>Z</b>[&#964;]</code>. Then
            <code>&#955;</code> is given as <code>&#955; = u + v&#964;</code>. The
            components <code>u</code> and <code>v</code> may be used directly, there
            are no accessor methods.
            Immutable class.
        </member>
        <member name="F:NBitcoin.BouncyCastle.Math.EC.Abc.ZTauElement.u">
            The &quot;real&quot; part of <code>&#955;</code>.
        </member>
        <member name="F:NBitcoin.BouncyCastle.Math.EC.Abc.ZTauElement.v">
            The &quot;<code>&#964;</code>-adic&quot; part of <code>&#955;</code>.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Math.EC.Abc.ZTauElement.#ctor(NBitcoin.BouncyCastle.Math.BigInteger,NBitcoin.BouncyCastle.Math.BigInteger)">
            Constructor for an element <code>&#955;</code> of
            <code><b>Z</b>[&#964;]</code>.
            @param u The &quot;real&quot; part of <code>&#955;</code>.
            @param v The &quot;<code>&#964;</code>-adic&quot; part of
            <code>&#955;</code>.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Math.EC.Custom.Sec.SecP256K1FieldElement.Sqrt">
            return a sqrt root - the routine verifies that the calculation returns the right value - if
            none exists it returns null.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Math.EC.Custom.Sec.SecP256K1Point.#ctor(NBitcoin.BouncyCastle.Math.EC.ECCurve,NBitcoin.BouncyCastle.Math.EC.ECFieldElement,NBitcoin.BouncyCastle.Math.EC.ECFieldElement)">
            Create a point which encodes with point compression.
            
            @param curve
                       the curve to use
            @param x
                       affine x co-ordinate
            @param y
                       affine y co-ordinate
            
            @deprecated Use ECCurve.createPoint to construct points
        </member>
        <member name="M:NBitcoin.BouncyCastle.Math.EC.Custom.Sec.SecP256K1Point.#ctor(NBitcoin.BouncyCastle.Math.EC.ECCurve,NBitcoin.BouncyCastle.Math.EC.ECFieldElement,NBitcoin.BouncyCastle.Math.EC.ECFieldElement,System.Boolean)">
            Create a point that encodes with or without point compresion.
            
            @param curve
                       the curve to use
            @param x
                       affine x co-ordinate
            @param y
                       affine y co-ordinate
            @param withCompression
                       if true encode with point compression
            
            @deprecated per-point compression property will be removed, refer
                        {@link #getEncoded(bool)}
        </member>
        <member name="M:NBitcoin.BouncyCastle.Math.EC.ECAlgorithms.ReferenceMultiply(NBitcoin.BouncyCastle.Math.EC.ECPoint,NBitcoin.BouncyCastle.Math.BigInteger)">
            Simple shift-and-add multiplication. Serves as reference implementation
            to verify (possibly faster) implementations, and for very small scalars.
            
            @param p
                       The point to multiply.
            @param k
                       The multiplier.
            @return The result of the point multiplication <code>kP</code>.
        </member>
        <member name="T:NBitcoin.BouncyCastle.Math.EC.ECCurve">
            <remarks>Base class for an elliptic curve.</remarks>
        </member>
        <member name="M:NBitcoin.BouncyCastle.Math.EC.ECCurve.SetPreCompInfo(NBitcoin.BouncyCastle.Math.EC.ECPoint,System.String,NBitcoin.BouncyCastle.Math.EC.Multiplier.PreCompInfo)">
            Adds <code>PreCompInfo</code> for a point on this curve, under a given name. Used by
            <code>ECMultiplier</code>s to save the precomputation for this <code>ECPoint</code> for use
            by subsequent multiplication.
            
            @param point
                       The <code>ECPoint</code> to store precomputations for.
            @param name
                       A <code>String</code> used to index precomputations of different types.
            @param preCompInfo
                       The values precomputed by the <code>ECMultiplier</code>.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Math.EC.ECCurve.NormalizeAll(NBitcoin.BouncyCastle.Math.EC.ECPoint[])">
            Normalization ensures that any projective coordinate is 1, and therefore that the x, y
            coordinates reflect those of the equivalent point in an affine coordinate system. Where more
            than one point is to be normalized, this method will generally be more efficient than
            normalizing each point separately.
            
            @param points
                       An array of points that will be updated in place with their normalized versions,
                       where necessary
        </member>
        <member name="M:NBitcoin.BouncyCastle.Math.EC.ECCurve.NormalizeAll(NBitcoin.BouncyCastle.Math.EC.ECPoint[],System.Int32,System.Int32,NBitcoin.BouncyCastle.Math.EC.ECFieldElement)">
            Normalization ensures that any projective coordinate is 1, and therefore that the x, y
            coordinates reflect those of the equivalent point in an affine coordinate system. Where more
            than one point is to be normalized, this method will generally be more efficient than
            normalizing each point separately. An (optional) z-scaling factor can be applied; effectively
            each z coordinate is scaled by this value prior to normalization (but only one
            actual multiplication is needed).
            
            @param points
                       An array of points that will be updated in place with their normalized versions,
                       where necessary
            @param off
                       The start of the range of points to normalize
            @param len
                       The length of the range of points to normalize
            @param iso
                       The (optional) z-scaling factor - can be null
        </member>
        <member name="M:NBitcoin.BouncyCastle.Math.EC.ECCurve.GetMultiplier">
            Sets the default <code>ECMultiplier</code>, unless already set. 
        </member>
        <member name="M:NBitcoin.BouncyCastle.Math.EC.ECCurve.DecodePoint(System.Byte[])">
            Decode a point on this curve from its ASN.1 encoding. The different
            encodings are taken account of, including point compression for
            <code>F<sub>p</sub></code> (X9.62 s 4.2.1 pg 17).
            @return The decoded point.
        </member>
        <member name="T:NBitcoin.BouncyCastle.Math.EC.FpCurve">
            Elliptic curve over Fp
        </member>
        <member name="F:NBitcoin.BouncyCastle.Math.EC.AbstractF2mCurve.si">
            The auxiliary values <code>s<sub>0</sub></code> and
            <code>s<sub>1</sub></code> used for partial modular reduction for
            Koblitz curves.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Math.EC.AbstractF2mCurve.SolveQuadradicEquation(NBitcoin.BouncyCastle.Math.EC.ECFieldElement)">
             Solves a quadratic equation <code>z<sup>2</sup> + z = beta</code>(X9.62
             D.1.6) The other solution is <code>z + 1</code>.
            
             @param beta
                        The value to solve the qradratic equation for.
             @return the solution for <code>z<sup>2</sup> + z = beta</code> or
                     <code>null</code> if no solution exists.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Math.EC.AbstractF2mCurve.GetSi">
            @return the auxiliary values <code>s<sub>0</sub></code> and
            <code>s<sub>1</sub></code> used for partial modular reduction for
            Koblitz curves.
        </member>
        <member name="P:NBitcoin.BouncyCastle.Math.EC.AbstractF2mCurve.IsKoblitz">
            Returns true if this is a Koblitz curve (ABC curve).
            @return true if this is a Koblitz curve (ABC curve), false otherwise
        </member>
        <member name="T:NBitcoin.BouncyCastle.Math.EC.F2mCurve">
            Elliptic curves over F2m. The Weierstrass equation is given by
            <code>y<sup>2</sup> + xy = x<sup>3</sup> + ax<sup>2</sup> + b</code>.
        </member>
        <member name="F:NBitcoin.BouncyCastle.Math.EC.F2mCurve.m">
            The exponent <code>m</code> of <code>F<sub>2<sup>m</sup></sub></code>.
        </member>
        <member name="F:NBitcoin.BouncyCastle.Math.EC.F2mCurve.k1">
            TPB: The integer <code>k</code> where <code>x<sup>m</sup> +
            x<sup>k</sup> + 1</code> represents the reduction polynomial
            <code>f(z)</code>.<br/>
            PPB: The integer <code>k1</code> where <code>x<sup>m</sup> +
            x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
            represents the reduction polynomial <code>f(z)</code>.<br/>
        </member>
        <member name="F:NBitcoin.BouncyCastle.Math.EC.F2mCurve.k2">
            TPB: Always set to <code>0</code><br/>
            PPB: The integer <code>k2</code> where <code>x<sup>m</sup> +
            x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
            represents the reduction polynomial <code>f(z)</code>.<br/>
        </member>
        <member name="F:NBitcoin.BouncyCastle.Math.EC.F2mCurve.k3">
            TPB: Always set to <code>0</code><br/>
            PPB: The integer <code>k3</code> where <code>x<sup>m</sup> +
            x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
            represents the reduction polynomial <code>f(z)</code>.<br/>
        </member>
        <member name="F:NBitcoin.BouncyCastle.Math.EC.F2mCurve.m_infinity">
            The point at infinity on this curve.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Math.EC.F2mCurve.#ctor(System.Int32,System.Int32,NBitcoin.BouncyCastle.Math.BigInteger,NBitcoin.BouncyCastle.Math.BigInteger)">
            Constructor for Trinomial Polynomial Basis (TPB).
            @param m  The exponent <code>m</code> of
            <code>F<sub>2<sup>m</sup></sub></code>.
            @param k The integer <code>k</code> where <code>x<sup>m</sup> +
            x<sup>k</sup> + 1</code> represents the reduction
            polynomial <code>f(z)</code>.
            @param a The coefficient <code>a</code> in the Weierstrass equation
            for non-supersingular elliptic curves over
            <code>F<sub>2<sup>m</sup></sub></code>.
            @param b The coefficient <code>b</code> in the Weierstrass equation
            for non-supersingular elliptic curves over
            <code>F<sub>2<sup>m</sup></sub></code>.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Math.EC.F2mCurve.#ctor(System.Int32,System.Int32,NBitcoin.BouncyCastle.Math.BigInteger,NBitcoin.BouncyCastle.Math.BigInteger,NBitcoin.BouncyCastle.Math.BigInteger,NBitcoin.BouncyCastle.Math.BigInteger)">
            Constructor for Trinomial Polynomial Basis (TPB).
            @param m  The exponent <code>m</code> of
            <code>F<sub>2<sup>m</sup></sub></code>.
            @param k The integer <code>k</code> where <code>x<sup>m</sup> +
            x<sup>k</sup> + 1</code> represents the reduction
            polynomial <code>f(z)</code>.
            @param a The coefficient <code>a</code> in the Weierstrass equation
            for non-supersingular elliptic curves over
            <code>F<sub>2<sup>m</sup></sub></code>.
            @param b The coefficient <code>b</code> in the Weierstrass equation
            for non-supersingular elliptic curves over
            <code>F<sub>2<sup>m</sup></sub></code>.
            @param order The order of the main subgroup of the elliptic curve.
            @param cofactor The cofactor of the elliptic curve, i.e.
            <code>#E<sub>a</sub>(F<sub>2<sup>m</sup></sub>) = h * n</code>.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Math.EC.F2mCurve.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,NBitcoin.BouncyCastle.Math.BigInteger,NBitcoin.BouncyCastle.Math.BigInteger)">
            Constructor for Pentanomial Polynomial Basis (PPB).
            @param m  The exponent <code>m</code> of
            <code>F<sub>2<sup>m</sup></sub></code>.
            @param k1 The integer <code>k1</code> where <code>x<sup>m</sup> +
            x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
            represents the reduction polynomial <code>f(z)</code>.
            @param k2 The integer <code>k2</code> where <code>x<sup>m</sup> +
            x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
            represents the reduction polynomial <code>f(z)</code>.
            @param k3 The integer <code>k3</code> where <code>x<sup>m</sup> +
            x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
            represents the reduction polynomial <code>f(z)</code>.
            @param a The coefficient <code>a</code> in the Weierstrass equation
            for non-supersingular elliptic curves over
            <code>F<sub>2<sup>m</sup></sub></code>.
            @param b The coefficient <code>b</code> in the Weierstrass equation
            for non-supersingular elliptic curves over
            <code>F<sub>2<sup>m</sup></sub></code>.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Math.EC.F2mCurve.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,NBitcoin.BouncyCastle.Math.BigInteger,NBitcoin.BouncyCastle.Math.BigInteger,NBitcoin.BouncyCastle.Math.BigInteger,NBitcoin.BouncyCastle.Math.BigInteger)">
            Constructor for Pentanomial Polynomial Basis (PPB).
            @param m  The exponent <code>m</code> of
            <code>F<sub>2<sup>m</sup></sub></code>.
            @param k1 The integer <code>k1</code> where <code>x<sup>m</sup> +
            x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
            represents the reduction polynomial <code>f(z)</code>.
            @param k2 The integer <code>k2</code> where <code>x<sup>m</sup> +
            x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
            represents the reduction polynomial <code>f(z)</code>.
            @param k3 The integer <code>k3</code> where <code>x<sup>m</sup> +
            x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
            represents the reduction polynomial <code>f(z)</code>.
            @param a The coefficient <code>a</code> in the Weierstrass equation
            for non-supersingular elliptic curves over
            <code>F<sub>2<sup>m</sup></sub></code>.
            @param b The coefficient <code>b</code> in the Weierstrass equation
            for non-supersingular elliptic curves over
            <code>F<sub>2<sup>m</sup></sub></code>.
            @param order The order of the main subgroup of the elliptic curve.
            @param cofactor The cofactor of the elliptic curve, i.e.
            <code>#E<sub>a</sub>(F<sub>2<sup>m</sup></sub>) = h * n</code>.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Math.EC.F2mCurve.IsTrinomial">
             Return true if curve uses a Trinomial basis.
            
             @return true if curve Trinomial, false otherwise.
        </member>
        <member name="P:NBitcoin.BouncyCastle.Math.EC.FpFieldElement.FieldName">
             return the field name for this field.
            
             @return the string "Fp".
        </member>
        <member name="M:NBitcoin.BouncyCastle.Math.EC.FpFieldElement.Sqrt">
            return a sqrt root - the routine verifies that the calculation
            returns the right value - if none exists it returns null.
        </member>
        <member name="T:NBitcoin.BouncyCastle.Math.EC.F2mFieldElement">
            Class representing the Elements of the finite field
            <code>F<sub>2<sup>m</sup></sub></code> in polynomial basis (PB)
            representation. Both trinomial (Tpb) and pentanomial (Ppb) polynomial
            basis representations are supported. Gaussian normal basis (GNB)
            representation is not supported.
        </member>
        <member name="F:NBitcoin.BouncyCastle.Math.EC.F2mFieldElement.Gnb">
            Indicates gaussian normal basis representation (GNB). Number chosen
            according to X9.62. GNB is not implemented at present.
        </member>
        <member name="F:NBitcoin.BouncyCastle.Math.EC.F2mFieldElement.Tpb">
            Indicates trinomial basis representation (Tpb). Number chosen
            according to X9.62.
        </member>
        <member name="F:NBitcoin.BouncyCastle.Math.EC.F2mFieldElement.Ppb">
            Indicates pentanomial basis representation (Ppb). Number chosen
            according to X9.62.
        </member>
        <member name="F:NBitcoin.BouncyCastle.Math.EC.F2mFieldElement.representation">
            Tpb or Ppb.
        </member>
        <member name="F:NBitcoin.BouncyCastle.Math.EC.F2mFieldElement.m">
            The exponent <code>m</code> of <code>F<sub>2<sup>m</sup></sub></code>.
        </member>
        <member name="F:NBitcoin.BouncyCastle.Math.EC.F2mFieldElement.x">
            The <code>LongArray</code> holding the bits.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Math.EC.F2mFieldElement.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,NBitcoin.BouncyCastle.Math.BigInteger)">
            Constructor for Ppb.
            @param m  The exponent <code>m</code> of
            <code>F<sub>2<sup>m</sup></sub></code>.
            @param k1 The integer <code>k1</code> where <code>x<sup>m</sup> +
            x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
            represents the reduction polynomial <code>f(z)</code>.
            @param k2 The integer <code>k2</code> where <code>x<sup>m</sup> +
            x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
            represents the reduction polynomial <code>f(z)</code>.
            @param k3 The integer <code>k3</code> where <code>x<sup>m</sup> +
            x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
            represents the reduction polynomial <code>f(z)</code>.
            @param x The BigInteger representing the value of the field element.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Math.EC.F2mFieldElement.#ctor(System.Int32,System.Int32,NBitcoin.BouncyCastle.Math.BigInteger)">
            Constructor for Tpb.
            @param m  The exponent <code>m</code> of
            <code>F<sub>2<sup>m</sup></sub></code>.
            @param k The integer <code>k</code> where <code>x<sup>m</sup> +
            x<sup>k</sup> + 1</code> represents the reduction
            polynomial <code>f(z)</code>.
            @param x The BigInteger representing the value of the field element.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Math.EC.F2mFieldElement.CheckFieldElements(NBitcoin.BouncyCastle.Math.EC.ECFieldElement,NBitcoin.BouncyCastle.Math.EC.ECFieldElement)">
            Checks, if the ECFieldElements <code>a</code> and <code>b</code>
            are elements of the same field <code>F<sub>2<sup>m</sup></sub></code>
            (having the same representation).
            @param a field element.
            @param b field element to be compared.
            @throws ArgumentException if <code>a</code> and <code>b</code>
            are not elements of the same field
            <code>F<sub>2<sup>m</sup></sub></code> (having the same
            representation).
        </member>
        <member name="P:NBitcoin.BouncyCastle.Math.EC.F2mFieldElement.Representation">
            @return the representation of the field
            <code>F<sub>2<sup>m</sup></sub></code>, either of
            {@link F2mFieldElement.Tpb} (trinomial
            basis representation) or
            {@link F2mFieldElement.Ppb} (pentanomial
            basis representation).
        </member>
        <member name="P:NBitcoin.BouncyCastle.Math.EC.F2mFieldElement.M">
            @return the degree <code>m</code> of the reduction polynomial
            <code>f(z)</code>.
        </member>
        <member name="P:NBitcoin.BouncyCastle.Math.EC.F2mFieldElement.K1">
            @return Tpb: The integer <code>k</code> where <code>x<sup>m</sup> +
            x<sup>k</sup> + 1</code> represents the reduction polynomial
            <code>f(z)</code>.<br/>
            Ppb: The integer <code>k1</code> where <code>x<sup>m</sup> +
            x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
            represents the reduction polynomial <code>f(z)</code>.<br/>
        </member>
        <member name="P:NBitcoin.BouncyCastle.Math.EC.F2mFieldElement.K2">
            @return Tpb: Always returns <code>0</code><br/>
            Ppb: The integer <code>k2</code> where <code>x<sup>m</sup> +
            x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
            represents the reduction polynomial <code>f(z)</code>.<br/>
        </member>
        <member name="P:NBitcoin.BouncyCastle.Math.EC.F2mFieldElement.K3">
            @return Tpb: Always set to <code>0</code><br/>
            Ppb: The integer <code>k3</code> where <code>x<sup>m</sup> +
            x<sup>k3</sup> + x<sup>k2</sup> + x<sup>k1</sup> + 1</code>
            represents the reduction polynomial <code>f(z)</code>.<br/>
        </member>
        <member name="T:NBitcoin.BouncyCastle.Math.EC.ECPoint">
            base class for points on elliptic curves.
        </member>
        <member name="P:NBitcoin.BouncyCastle.Math.EC.ECPoint.X">
            Normalizes this point, and then returns the affine x-coordinate.
            
            Note: normalization can be expensive, this method is deprecated in favour
            of caller-controlled normalization.
        </member>
        <member name="P:NBitcoin.BouncyCastle.Math.EC.ECPoint.Y">
            Normalizes this point, and then returns the affine y-coordinate.
            
            Note: normalization can be expensive, this method is deprecated in favour
            of caller-controlled normalization.
        </member>
        <member name="P:NBitcoin.BouncyCastle.Math.EC.ECPoint.AffineXCoord">
            Returns the affine x-coordinate after checking that this point is normalized.
            
            @return The affine x-coordinate of this point
            @throws IllegalStateException if the point is not normalized
        </member>
        <member name="P:NBitcoin.BouncyCastle.Math.EC.ECPoint.AffineYCoord">
            Returns the affine y-coordinate after checking that this point is normalized
            
            @return The affine y-coordinate of this point
            @throws IllegalStateException if the point is not normalized
        </member>
        <member name="P:NBitcoin.BouncyCastle.Math.EC.ECPoint.XCoord">
            Returns the x-coordinate.
            
            Caution: depending on the curve's coordinate system, this may not be the same value as in an
            affine coordinate system; use Normalize() to get a point where the coordinates have their
            affine values, or use AffineXCoord if you expect the point to already have been normalized.
            
            @return the x-coordinate of this point
        </member>
        <member name="P:NBitcoin.BouncyCastle.Math.EC.ECPoint.YCoord">
            Returns the y-coordinate.
            
            Caution: depending on the curve's coordinate system, this may not be the same value as in an
            affine coordinate system; use Normalize() to get a point where the coordinates have their
            affine values, or use AffineYCoord if you expect the point to already have been normalized.
            
            @return the y-coordinate of this point
        </member>
        <member name="M:NBitcoin.BouncyCastle.Math.EC.ECPoint.Normalize">
            Normalization ensures that any projective coordinate is 1, and therefore that the x, y
            coordinates reflect those of the equivalent point in an affine coordinate system.
            
            @return a new ECPoint instance representing the same point, but with normalized coordinates
        </member>
        <member name="M:NBitcoin.BouncyCastle.Math.EC.ECPointBase.GetEncoded(System.Boolean)">
            return the field element encoded with point compression. (S 4.3.6)
        </member>
        <member name="M:NBitcoin.BouncyCastle.Math.EC.ECPointBase.Multiply(NBitcoin.BouncyCastle.Math.BigInteger)">
            Multiplies this <code>ECPoint</code> by the given number.
            @param k The multiplicator.
            @return <code>k * this</code>.
        </member>
        <member name="T:NBitcoin.BouncyCastle.Math.EC.FpPoint">
            Elliptic curve points over Fp
        </member>
        <member name="M:NBitcoin.BouncyCastle.Math.EC.FpPoint.#ctor(NBitcoin.BouncyCastle.Math.EC.ECCurve,NBitcoin.BouncyCastle.Math.EC.ECFieldElement,NBitcoin.BouncyCastle.Math.EC.ECFieldElement)">
             Create a point which encodes without point compression.
            
             @param curve the curve to use
             @param x affine x co-ordinate
             @param y affine y co-ordinate
        </member>
        <member name="M:NBitcoin.BouncyCastle.Math.EC.FpPoint.#ctor(NBitcoin.BouncyCastle.Math.EC.ECCurve,NBitcoin.BouncyCastle.Math.EC.ECFieldElement,NBitcoin.BouncyCastle.Math.EC.ECFieldElement,System.Boolean)">
             Create a point that encodes with or without point compression.
            
             @param curve the curve to use
             @param x affine x co-ordinate
             @param y affine y co-ordinate
             @param withCompression if true encode with point compression
        </member>
        <member name="T:NBitcoin.BouncyCastle.Math.EC.F2mPoint">
            Elliptic curve points over F2m
        </member>
        <member name="M:NBitcoin.BouncyCastle.Math.EC.F2mPoint.#ctor(NBitcoin.BouncyCastle.Math.EC.ECCurve,NBitcoin.BouncyCastle.Math.EC.ECFieldElement,NBitcoin.BouncyCastle.Math.EC.ECFieldElement)">
            @param curve base curve
            @param x x point
            @param y y point
        </member>
        <member name="M:NBitcoin.BouncyCastle.Math.EC.F2mPoint.#ctor(NBitcoin.BouncyCastle.Math.EC.ECCurve,NBitcoin.BouncyCastle.Math.EC.ECFieldElement,NBitcoin.BouncyCastle.Math.EC.ECFieldElement,System.Boolean)">
            @param curve base curve
            @param x x point
            @param y y point
            @param withCompression true if encode with point compression.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Math.EC.F2mPoint.#ctor(NBitcoin.BouncyCastle.Math.EC.ECCurve)">
            Constructor for point at infinity
        </member>
        <member name="M:NBitcoin.BouncyCastle.Math.EC.Multiplier.DoubleAddMultiplier.MultiplyPositive(NBitcoin.BouncyCastle.Math.EC.ECPoint,NBitcoin.BouncyCastle.Math.BigInteger)">
            Joye's double-add algorithm.
        </member>
        <member name="T:NBitcoin.BouncyCastle.Math.EC.Multiplier.ECMultiplier">
            Interface for classes encapsulating a point multiplication algorithm
            for <code>ECPoint</code>s.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Math.EC.Multiplier.ECMultiplier.Multiply(NBitcoin.BouncyCastle.Math.EC.ECPoint,NBitcoin.BouncyCastle.Math.BigInteger)">
            Multiplies the <code>ECPoint p</code> by <code>k</code>, i.e.
            <code>p</code> is added <code>k</code> times to itself.
            @param p The <code>ECPoint</code> to be multiplied.
            @param k The factor by which <code>p</code> is multiplied.
            @return <code>p</code> multiplied by <code>k</code>.
        </member>
        <member name="T:NBitcoin.BouncyCastle.Math.EC.Multiplier.FixedPointPreCompInfo">
            Class holding precomputation data for fixed-point multiplications.
        </member>
        <member name="F:NBitcoin.BouncyCastle.Math.EC.Multiplier.FixedPointPreCompInfo.m_preComp">
            Array holding the precomputed <code>ECPoint</code>s used for a fixed
            point multiplication.
        </member>
        <member name="F:NBitcoin.BouncyCastle.Math.EC.Multiplier.FixedPointPreCompInfo.m_width">
            The width used for the precomputation. If a larger width precomputation
            is already available this may be larger than was requested, so calling
            code should refer to the actual width.
        </member>
        <member name="T:NBitcoin.BouncyCastle.Math.EC.Multiplier.PreCompInfo">
            Interface for classes storing precomputation data for multiplication
            algorithms. Used as a Memento (see GOF patterns) for
            <code>WNafMultiplier</code>.
        </member>
        <member name="T:NBitcoin.BouncyCastle.Math.EC.Multiplier.WNafL2RMultiplier">
            Class implementing the WNAF (Window Non-Adjacent Form) multiplication
            algorithm.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Math.EC.Multiplier.WNafL2RMultiplier.MultiplyPositive(NBitcoin.BouncyCastle.Math.EC.ECPoint,NBitcoin.BouncyCastle.Math.BigInteger)">
            Multiplies <code>this</code> by an integer <code>k</code> using the
            Window NAF method.
            @param k The integer by which <code>this</code> is multiplied.
            @return A new <code>ECPoint</code> which equals <code>this</code>
            multiplied by <code>k</code>.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Math.EC.Multiplier.WNafL2RMultiplier.GetWindowSize(System.Int32)">
            Determine window width to use for a scalar multiplication of the given size.
            
            @param bits the bit-length of the scalar to multiply by
            @return the window size to use
        </member>
        <member name="T:NBitcoin.BouncyCastle.Math.EC.Multiplier.WNafPreCompInfo">
            Class holding precomputation data for the WNAF (Window Non-Adjacent Form)
            algorithm.
        </member>
        <member name="F:NBitcoin.BouncyCastle.Math.EC.Multiplier.WNafPreCompInfo.m_preComp">
            Array holding the precomputed <code>ECPoint</code>s used for a Window
            NAF multiplication.
        </member>
        <member name="F:NBitcoin.BouncyCastle.Math.EC.Multiplier.WNafPreCompInfo.m_preCompNeg">
            Array holding the negations of the precomputed <code>ECPoint</code>s used
            for a Window NAF multiplication.
        </member>
        <member name="F:NBitcoin.BouncyCastle.Math.EC.Multiplier.WNafPreCompInfo.m_twice">
            Holds an <code>ECPoint</code> representing Twice(this). Used for the
            Window NAF multiplication to create or extend the precomputed values.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Math.EC.Multiplier.WNafUtilities.GenerateWindowNaf(System.Int32,NBitcoin.BouncyCastle.Math.BigInteger)">
            Computes the Window NAF (non-adjacent Form) of an integer.
            @param width The width <code>w</code> of the Window NAF. The width is
            defined as the minimal number <code>w</code>, such that for any
            <code>w</code> consecutive digits in the resulting representation, at
            most one is non-zero.
            @param k The integer of which the Window NAF is computed.
            @return The Window NAF of the given width, such that the following holds:
            <code>k = &amp;sum;<sub>i=0</sub><sup>l-1</sup> k<sub>i</sub>2<sup>i</sup>
            </code>, where the <code>k<sub>i</sub></code> denote the elements of the
            returned <code>byte[]</code>.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Math.EC.Multiplier.WNafUtilities.GetWindowSize(System.Int32)">
            Determine window width to use for a scalar multiplication of the given size.
            
            @param bits the bit-length of the scalar to multiply by
            @return the window size to use
        </member>
        <member name="M:NBitcoin.BouncyCastle.Math.EC.Multiplier.WNafUtilities.GetWindowSize(System.Int32,System.Int32[])">
            Determine window width to use for a scalar multiplication of the given size.
            
            @param bits the bit-length of the scalar to multiply by
            @param windowSizeCutoffs a monotonically increasing list of bit sizes at which to increment the window width
            @return the window size to use
        </member>
        <member name="T:NBitcoin.BouncyCastle.Math.EC.Multiplier.WTauNafMultiplier">
            Class implementing the WTNAF (Window
            <code>&#964;</code>-adic Non-Adjacent Form) algorithm.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Math.EC.Multiplier.WTauNafMultiplier.MultiplyPositive(NBitcoin.BouncyCastle.Math.EC.ECPoint,NBitcoin.BouncyCastle.Math.BigInteger)">
            Multiplies a {@link NBitcoin.BouncyCastle.math.ec.AbstractF2mPoint AbstractF2mPoint}
            by <code>k</code> using the reduced <code>&#964;</code>-adic NAF (RTNAF)
            method.
            @param p The AbstractF2mPoint to multiply.
            @param k The integer by which to multiply <code>k</code>.
            @return <code>p</code> multiplied by <code>k</code>.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Math.EC.Multiplier.WTauNafMultiplier.MultiplyWTnaf(NBitcoin.BouncyCastle.Math.EC.AbstractF2mPoint,NBitcoin.BouncyCastle.Math.EC.Abc.ZTauElement,NBitcoin.BouncyCastle.Math.EC.Multiplier.PreCompInfo,System.SByte,System.SByte)">
            Multiplies a {@link NBitcoin.BouncyCastle.math.ec.AbstractF2mPoint AbstractF2mPoint}
            by an element <code>&#955;</code> of <code><b>Z</b>[&#964;]</code> using
            the <code>&#964;</code>-adic NAF (TNAF) method.
            @param p The AbstractF2mPoint to multiply.
            @param lambda The element <code>&#955;</code> of
            <code><b>Z</b>[&#964;]</code> of which to compute the
            <code>[&#964;]</code>-adic NAF.
            @return <code>p</code> multiplied by <code>&#955;</code>.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Math.EC.Multiplier.WTauNafMultiplier.MultiplyFromWTnaf(NBitcoin.BouncyCastle.Math.EC.AbstractF2mPoint,System.SByte[],NBitcoin.BouncyCastle.Math.EC.Multiplier.PreCompInfo)">
            Multiplies a {@link NBitcoin.BouncyCastle.math.ec.AbstractF2mPoint AbstractF2mPoint}
            by an element <code>&#955;</code> of <code><b>Z</b>[&#964;]</code>
            using the window <code>&#964;</code>-adic NAF (TNAF) method, given the
            WTNAF of <code>&#955;</code>.
            @param p The AbstractF2mPoint to multiply.
            @param u The the WTNAF of <code>&#955;</code>..
            @return <code>&#955; * p</code>
        </member>
        <member name="T:NBitcoin.BouncyCastle.Math.EC.Multiplier.WTauNafPreCompInfo">
            Class holding precomputation data for the WTNAF (Window
            <code>&#964;</code>-adic Non-Adjacent Form) algorithm.
        </member>
        <member name="F:NBitcoin.BouncyCastle.Math.EC.Multiplier.WTauNafPreCompInfo.m_preComp">
            Array holding the precomputed <code>AbstractF2mPoint</code>s used for the
            WTNAF multiplication in <code>
            {@link NBitcoin.BouncyCastle.math.ec.multiplier.WTauNafMultiplier.multiply()
            WTauNafMultiplier.multiply()}</code>.
        </member>
        <member name="T:NBitcoin.BouncyCastle.Utilities.Arrays">
            <summary> General array utilities.</summary>
        </member>
        <member name="M:NBitcoin.BouncyCastle.Utilities.Arrays.AreEqual(System.Byte[],System.Byte[])">
            <summary>
            Are two arrays equal.
            </summary>
            <param name="a">Left side.</param>
            <param name="b">Right side.</param>
            <returns>True if equal.</returns>
        </member>
        <member name="M:NBitcoin.BouncyCastle.Utilities.Arrays.ConstantTimeAreEqual(System.Byte[],System.Byte[])">
            <summary>
            A constant time equals comparison - does not terminate early if
            test will fail.
            </summary>
            <param name="a">first array</param>
            <param name="b">second array</param>
            <returns>true if arrays equal, false otherwise.</returns>
        </member>
        <member name="M:NBitcoin.BouncyCastle.Utilities.Arrays.CopyOfRange(System.Byte[],System.Int32,System.Int32)">
             Make a copy of a range of bytes from the passed in data array. The range can
             extend beyond the end of the input array, in which case the return array will
             be padded with zeroes.
            
             @param data the array from which the data is to be copied.
             @param from the start index at which the copying should take place.
             @param to the final index of the range (exclusive).
            
             @return a new byte array containing the range given.
        </member>
        <member name="T:NBitcoin.BouncyCastle.Utilities.BigIntegers">
            BigInteger utilities.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Utilities.BigIntegers.AsUnsignedByteArray(NBitcoin.BouncyCastle.Math.BigInteger)">
             Return the passed in value as an unsigned byte array.
            
             @param value value to be converted.
             @return a byte array without a leading zero byte if present in the signed encoding.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Utilities.BigIntegers.AsUnsignedByteArray(System.Int32,NBitcoin.BouncyCastle.Math.BigInteger)">
             Return the passed in value as an unsigned byte array of specified length, zero-extended as necessary.
            
             @param length desired length of result array.
             @param n value to be converted.
             @return a byte array of specified length, with leading zeroes as necessary given the size of n.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Utilities.BigIntegers.CreateRandomInRange(NBitcoin.BouncyCastle.Math.BigInteger,NBitcoin.BouncyCastle.Math.BigInteger,NBitcoin.BouncyCastle.Security.SecureRandom)">
            Return a random BigInteger not less than 'min' and not greater than 'max'
            
            @param min the least value that may be generated
            @param max the greatest value that may be generated
            @param random the source of randomness
            @return a random BigInteger value in the range [min,max]
        </member>
        <member name="T:NBitcoin.BouncyCastle.Utilities.Encoders.Hex">
            <summary>
            Class to decode and encode Hex.
            </summary>
        </member>
        <member name="M:NBitcoin.BouncyCastle.Utilities.Encoders.Hex.Encode(System.Byte[])">
             encode the input data producing a Hex encoded byte array.
            
             @return a byte array containing the Hex encoded data.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Utilities.Encoders.Hex.Encode(System.Byte[],System.Int32,System.Int32)">
             encode the input data producing a Hex encoded byte array.
            
             @return a byte array containing the Hex encoded data.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Utilities.Encoders.Hex.Encode(System.Byte[],System.IO.Stream)">
             Hex encode the byte data writing it to the given output stream.
            
             @return the number of bytes produced.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Utilities.Encoders.Hex.Encode(System.Byte[],System.Int32,System.Int32,System.IO.Stream)">
             Hex encode the byte data writing it to the given output stream.
            
             @return the number of bytes produced.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Utilities.Encoders.Hex.Decode(System.Byte[])">
             decode the Hex encoded input data. It is assumed the input data is valid.
            
             @return a byte array representing the decoded data.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Utilities.Encoders.Hex.Decode(System.String)">
             decode the Hex encoded string data - whitespace will be ignored.
            
             @return a byte array representing the decoded data.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Utilities.Encoders.Hex.Decode(System.String,System.IO.Stream)">
             decode the Hex encoded string data writing it to the given output stream,
             whitespace characters will be ignored.
            
             @return the number of bytes produced.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Utilities.Encoders.HexEncoder.Encode(System.Byte[],System.Int32,System.Int32,System.IO.Stream)">
             encode the input data producing a Hex output stream.
            
             @return the number of bytes produced.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Utilities.Encoders.HexEncoder.Decode(System.Byte[],System.Int32,System.Int32,System.IO.Stream)">
             decode the Hex encoded byte data writing it to the given output stream,
             whitespace characters will be ignored.
            
             @return the number of bytes produced.
        </member>
        <member name="M:NBitcoin.BouncyCastle.Utilities.Encoders.HexEncoder.DecodeString(System.String,System.IO.Stream)">
             decode the Hex encoded string data writing it to the given output stream,
             whitespace characters will be ignored.
            
             @return the number of bytes produced.
        </member>
        <member name="T:NBitcoin.BouncyCastle.Utilities.Encoders.IEncoder">
            Encode and decode byte arrays (typically from binary to 7-bit ASCII
            encodings).
        </member>
        <member name="M:NBitcoin.BouncyCastle.Utilities.IMemoable.Copy">
            <summary>
            Produce a copy of this object with its configuration and in its current state.
            </summary>
            <remarks>
            The returned object may be used simply to store the state, or may be used as a similar object
            starting from the copied state.
            </remarks>
        </member>
        <member name="M:NBitcoin.BouncyCastle.Utilities.IMemoable.Reset(NBitcoin.BouncyCastle.Utilities.IMemoable)">
            <summary>
            Restore a copied object state into this object.
            </summary>
            <remarks>
            Implementations of this method <em>should</em> try to avoid or minimise memory allocation to perform the reset.
            </remarks>
            <param name="other">an object originally {@link #copy() copied} from an object of the same type as this instance.</param>
            <exception cref="T:System.InvalidCastException">if the provided object is not of the correct type.</exception>
        </member>
        <member name="M:NBitcoin.BouncyCastle.Utilities.IO.Streams.PipeAllLimited(System.IO.Stream,System.Int64,System.IO.Stream)">
            <summary>
            Pipe all bytes from <c>inStr</c> to <c>outStr</c>, throwing <c>StreamFlowException</c> if greater
            than <c>limit</c> bytes in <c>inStr</c>.
            </summary>
            <param name="inStr">
            A <see cref="T:System.IO.Stream"/>
            </param>
            <param name="limit">
            A <see cref="T:System.Int64"/>
            </param>
            <param name="outStr">
            A <see cref="T:System.IO.Stream"/>
            </param>
            <returns>The number of bytes actually transferred, if not greater than <c>limit</c></returns>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="T:NBitcoin.BuilderExtensions.BuilderExtension">
            <summary>
            Base extension class to derive from for extending the TransactionBuilder
            </summary>
        </member>
        <member name="M:NBitcoin.ChainBase.FindFork(NBitcoin.ChainBase)">
            <summary>
            Returns the first common block between two chains
            </summary>
            <param name="chain">The other chain</param>
            <returns>First common block or null</returns>
        </member>
        <member name="M:NBitcoin.ChainBase.FindFork(System.Collections.Generic.IEnumerable{NBitcoin.uint256})">
            <summary>
            Returns the first found block
            </summary>
            <param name="hashes">Hash to search for</param>
            <returns>First found block or null</returns>
        </member>
        <member name="M:NBitcoin.ChainBase.SetTip(NBitcoin.ChainedBlock)">
            <summary>
            Force a new tip for the chain
            </summary>
            <param name="pindex"></param>
            <returns>forking point</returns>
        </member>
        <member name="T:NBitcoin.ChainedBlock">
            <summary>
            A BlockHeader chained with all its ancestors
            </summary>
        </member>
        <member name="M:NBitcoin.ChainedBlock.StripCachedData">
            <summary>
            Free up some memory (cached HashBlock and ChainWork) at the price of efficiency
            </summary>
        </member>
        <member name="M:NBitcoin.ChainedBlock.StripHeader">
            <summary>
            Strip the Header to free up memory
            </summary>
        </member>
        <member name="P:NBitcoin.ChainedBlock.HasHeader">
            <summary>
            Returns true if this ChainedBlock has the underlying header
            </summary>
        </member>
        <member name="M:NBitcoin.ChainedBlock.TryGetHeader(NBitcoin.BlockHeader@)">
            <summary>
            Get the BlockHeader
            </summary>
            <param name="header">The block header</param>
            <returns>True if this ChainedBlock has block header</returns>
        </member>
        <member name="P:NBitcoin.ChainedBlock.Header">
            <summary>
            Get the underlying block header, throws if the Header is not present.
            </summary>
        </member>
        <member name="M:NBitcoin.ChainedBlock.GetChainWork(System.Boolean)">
            <summary>
            Get the value of the chain work
            </summary>
            <param name="cacheResult">If true, called GetChainWork on this block and future block will be faster, but this trade for space</param>
            <returns>The chain work value</returns>
        </member>
        <member name="M:NBitcoin.ChainedBlock.Validate(NBitcoin.Network)">
            <summary>
            Check PoW and that the blocks connect correctly
            </summary>
            <param name="network">The network being used</param>
            <returns>True if PoW is correct</returns>
        </member>
        <member name="M:NBitcoin.ChainedBlock.Validate(NBitcoin.Consensus)">
            <summary>
            Check PoW and that the blocks connect correctly
            </summary>
            <param name="consensus">The consensus being used</param>
            <returns>True if PoW is correct</returns>
        </member>
        <member name="M:NBitcoin.ChainedBlock.FindFork(NBitcoin.ChainedBlock)">
            <summary>
            Find first common block between two chains
            </summary>
            <param name="block">The tip of the other chain</param>
            <returns>First common block or null</returns>
        </member>
        <member name="M:NBitcoin.ICoin.GetScriptCode">
            <summary>
            Returns the script actually signed and executed
            </summary>
            <exception cref="T:System.InvalidOperationException">Additional information needed to get the ScriptCode</exception>
            <returns>The executed script</returns>
        </member>
        <member name="T:NBitcoin.ScriptCoin">
            <summary>
            Represent a coin which need a redeem script to be spent (P2SH or P2WSH)
            </summary>
        </member>
        <member name="M:NBitcoin.ScriptCoin.GetRedeemHash(NBitcoin.Script)">
            <summary>
            Returns the hash contained in the scriptPubKey (P2SH or P2WSH)
            </summary>
            <param name="scriptPubKey">The scriptPubKey</param>
            <returns>The hash of the scriptPubkey</returns>
        </member>
        <member name="M:NBitcoin.StealthCoin.Find(NBitcoin.Transaction,NBitcoin.Stealth.BitcoinStealthAddress,NBitcoin.Key)">
            <summary>
            Scan the Transaction for StealthCoin given address and scan key
            </summary>
            <param name="tx">The transaction to scan</param>
            <param name="address">The stealth address</param>
            <param name="scan">The scan private key</param>
            <returns></returns>
        </member>
        <member name="T:NBitcoin.ConcurrentChain">
            <summary>
            Thread safe class representing a chain of headers from genesis
            </summary>
        </member>
        <member name="M:NBitcoin.ConcurrentChain.SetTip(NBitcoin.ChainedBlock)">
            <summary>
            Force a new tip for the chain
            </summary>
            <param name="pindex"></param>
            <returns>forking point</returns>
        </member>
        <member name="T:NBitcoin.Crypto.Pbkdf2">
             <summary>
             Implements the PBKDF2 key derivation function.
             </summary>
             
             <example>
             <code title="Computing a Derived Key">
             using System.Security.Cryptography;
             using CryptSharp.Utility;
             
             // Compute a 128-byte derived key using HMAC-SHA256, 1000 iterations, and a given key and salt.
             byte[] derivedKey = Pbkdf2.ComputeDerivedKey(new HMACSHA256(key), salt, 1000, 128);
             </code>
             <code title="Creating a Derived Key Stream">
             using System.IO;
             using System.Security.Cryptography;
             using CryptSharp.Utility;
            
             // Create a stream using HMAC-SHA512, 1000 iterations, and a given key and salt.
             Stream derivedKeyStream = new Pbkdf2(new HMACSHA512(key), salt, 1000);
             </code>
             </example>
        </member>
        <member name="M:NBitcoin.Crypto.Pbkdf2.#ctor(NBitcoin.BouncyCastle.Crypto.IMac,System.Byte[],System.Int32)">
            <summary>
            Creates a new PBKDF2 stream.
            </summary>
            <param name="hmacAlgorithm">
            </param>
            <param name="salt">
                The salt.
                A unique salt means a unique PBKDF2 stream, even if the original key is identical.
            </param>
            <param name="iterations">The number of iterations to apply.</param>
        </member>
        <member name="M:NBitcoin.Crypto.Pbkdf2.Read(System.Int32)">
            <summary>
            Reads from the derived key stream.
            </summary>
            <param name="count">The number of bytes to read.</param>
            <returns>Bytes from the derived key stream.</returns>
        </member>
        <member name="M:NBitcoin.Crypto.Pbkdf2.ComputeDerivedKey(NBitcoin.BouncyCastle.Crypto.IMac,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Computes a derived key.
            </summary>
            <param name="hmacAlgorithm">
            </param>
            <param name="salt">
                The salt.
                A unique salt means a unique derived key, even if the original key is identical.
            </param>
            <param name="iterations">The number of iterations to apply.</param>
            <param name="derivedKeyLength">The desired length of the derived key.</param>
            <returns>The derived key.</returns>
        </member>
        <member name="M:NBitcoin.Crypto.Pbkdf2.Dispose(System.Boolean)">
            <summary>
            Closes the stream, clearing memory and disposing of the HMAC algorithm.
            </summary>
        </member>
        <member name="M:NBitcoin.Crypto.Pbkdf2.Flush">
            <exclude />
        </member>
        <member name="M:NBitcoin.Crypto.Pbkdf2.Read(System.Byte[],System.Int32,System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:NBitcoin.Crypto.Pbkdf2.Seek(System.Int64,System.IO.SeekOrigin)">
            <inheritdoc />
        </member>
        <member name="M:NBitcoin.Crypto.Pbkdf2.SetLength(System.Int64)">
            <exclude />
        </member>
        <member name="M:NBitcoin.Crypto.Pbkdf2.Write(System.Byte[],System.Int32,System.Int32)">
            <exclude />
        </member>
        <member name="P:NBitcoin.Crypto.Pbkdf2.CanRead">
            <exclude />
        </member>
        <member name="P:NBitcoin.Crypto.Pbkdf2.CanSeek">
            <exclude />
        </member>
        <member name="P:NBitcoin.Crypto.Pbkdf2.CanWrite">
            <exclude />
        </member>
        <member name="P:NBitcoin.Crypto.Pbkdf2.Length">
            <summary>
            The maximum number of bytes that can be derived is 2^32-1 times the HMAC size.
            </summary>
        </member>
        <member name="P:NBitcoin.Crypto.Pbkdf2.Position">
            <summary>
            The position within the derived key stream.
            </summary>
        </member>
        <member name="T:NBitcoin.Crypto.Salsa20Core">
            <summary>
            Implements the Salsa20 hash function.
            </summary>
        </member>
        <member name="M:NBitcoin.Crypto.Salsa20Core.Compute(System.Int32,System.UInt32[],System.Int32,System.UInt32[],System.Int32)">
            <summary>
            Applies the Salsa20 hash function.
            It maps a 16 element input to an output of the same size.
            </summary>
            <param name="rounds">The number of rounds. SCrypt uses 8.</param>
            <param name="input">The input buffer.</param>
            <param name="inputOffset">The offset into the input buffer.</param>
            <param name="output">The output buffer.</param>
            <param name="outputOffset">The offset into the output buffer.</param>
        </member>
        <member name="T:NBitcoin.Crypto.SCrypt">
            <summary>
            Implements the SCrypt key derivation function.
            </summary>
        </member>
        <member name="M:NBitcoin.Crypto.SCrypt.ComputeDerivedKey(System.Byte[],System.Byte[],System.Int32,System.Int32,System.Int32,System.Nullable{System.Int32},System.Int32)">
            <summary>
            Computes a derived key.
            </summary>
            <param name="key">The key to derive from.</param>
            <param name="salt">
                The salt.
                A unique salt means a unique SCrypt stream, even if the original key is identical.
            </param>
            <param name="cost">
                The cost parameter, typically a fairly large number such as 262144.
                Memory usage and CPU time scale approximately linearly with this parameter.
            </param>
            <param name="blockSize">
                The mixing block size, typically 8.
                Memory usage and CPU time scale approximately linearly with this parameter.
            </param>
            <param name="parallel">
                The level of parallelism, typically 1.
                CPU time scales approximately linearly with this parameter.
            </param>
            <param name="maxThreads">
                The maximum number of threads to spawn to derive the key.
                This is limited by the <paramref name="parallel"/> value.
                <c>null</c> will use as many threads as possible.
            </param>
            <param name="derivedKeyLength">The desired length of the derived key.</param>
            <returns>The derived key.</returns>
        </member>
        <member name="M:NBitcoin.Crypto.SCrypt.GetEffectivePbkdf2Salt(System.Byte[],System.Byte[],System.Int32,System.Int32,System.Int32,System.Nullable{System.Int32})">
            <summary>
            The SCrypt algorithm creates a salt which it then uses as a one-iteration
            PBKDF2 key stream with SHA256 HMAC. This method lets you retrieve this intermediate salt.
            </summary>
            <param name="key">The key to derive from.</param>
            <param name="salt">
                The salt.
                A unique salt means a unique SCrypt stream, even if the original key is identical.
            </param>
            <param name="cost">
                The cost parameter, typically a fairly large number such as 262144.
                Memory usage and CPU time scale approximately linearly with this parameter.
            </param>
            <param name="blockSize">
                The mixing block size, typically 8.
                Memory usage and CPU time scale approximately linearly with this parameter.
            </param>
            <param name="parallel">
                The level of parallelism, typically 1.
                CPU time scales approximately linearly with this parameter.
            </param>
            <param name="maxThreads">
                The maximum number of threads to spawn to derive the key.
                This is limited by the <paramref name="parallel"/> value.
                <c>null</c> will use as many threads as possible.
            </param>
            <returns>The effective salt.</returns>
        </member>
        <member name="M:NBitcoin.Crypto.SCrypt.GetStream(System.Byte[],System.Byte[],System.Int32,System.Int32,System.Int32,System.Nullable{System.Int32})">
            <summary>
            Creates a derived key stream from which a derived key can be read.
            </summary>
            <param name="key">The key to derive from.</param>
            <param name="salt">
                The salt.
                A unique salt means a unique scrypt stream, even if the original key is identical.
            </param>
            <param name="cost">
                The cost parameter, typically a fairly large number such as 262144.
                Memory usage and CPU time scale approximately linearly with this parameter.
            </param>
            <param name="blockSize">
                The mixing block size, typically 8.
                Memory usage and CPU time scale approximately linearly with this parameter.
            </param>
            <param name="parallel">
                The level of parallelism, typically 1.
                CPU time scales approximately linearly with this parameter.
            </param>
            <param name="maxThreads">
                The maximum number of threads to spawn to derive the key.
                This is limited by the <paramref name="parallel"/> value.
                <c>null</c> will use as many threads as possible.
            </param>
            <returns>The derived key stream.</returns>
        </member>
        <member name="M:NBitcoin.Crypto.ECDSASignature.ToDER">
            What we get back from the signer are the two components of a signature, r and s. To get a flat byte stream
            of the type used by Bitcoin we have to encode them using DER encoding, which is just a way to pack the two
            components into a structure.
        </member>
        <member name="M:NBitcoin.Crypto.ECDSASignature.MakeCanonical">
            <summary>
            Enforce LowS on the signature
            </summary>
        </member>
        <member name="P:NBitcoin.FeeRate.FeePerK">
            <summary>
            Fee per KB
            </summary>
        </member>
        <member name="M:NBitcoin.FeeRate.GetFee(System.Int32)">
            <summary>
            Get fee for the size
            </summary>
            <param name="virtualSize">Size in bytes</param>
            <returns></returns>
        </member>
        <member name="T:NBitcoin.IDestination">
            <summary>
            Represent any type which represent an underlying ScriptPubKey
            </summary>
        </member>
        <member name="T:NBitcoin.ITransactionRepository">
            <summary>
            Represent a transaction map
            </summary>
        </member>
        <member name="M:NBitcoin.Key.GetWif(NBitcoin.Network)">
            <summary>
            Same than GetBitcoinSecret
            </summary>
            <param name="network"></param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.MoneyBag.GetAmount(NBitcoin.OpenAsset.AssetId)">
            <summary>
            Get the Money corresponding to the input assetId
            </summary>
            <param name="assetId">The asset id, if null, will assume bitcoin amount</param>
            <returns>Never returns null, eithers the AssetMoney or Money if assetId is null</returns>
        </member>
        <member name="M:NBitcoin.MoneyBag.Split(System.Int32)">
            <summary>
            Split the MoneyBag in several one, without loss
            </summary>
            <param name="parts">The number of parts (must be more than 0)</param>
            <returns>The splitted money</returns>
        </member>
        <member name="M:NBitcoin.Money.TryParse(System.String,NBitcoin.Money@)">
            <summary>
            Parse a bitcoin amount (Culture Invariant)
            </summary>
            <param name="bitcoin"></param>
            <param name="nRet"></param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.Money.Parse(System.String)">
            <summary>
            Parse a bitcoin amount (Culture Invariant)
            </summary>
            <param name="bitcoin"></param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.Money.Abs">
            <summary>
            Get absolute value of the instance
            </summary>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.Money.Split(System.Int32)">
            <summary>
            Split the Money in parts without loss
            </summary>
            <param name="parts">The number of parts (must be more than 0)</param>
            <returns>The splitted money</returns>
        </member>
        <member name="M:NBitcoin.Money.ToUnit(NBitcoin.MoneyUnit)">
            <summary>
            Convert Money to decimal (same as ToDecimal)
            </summary>
            <param name="unit"></param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.Money.ToDecimal(NBitcoin.MoneyUnit)">
            <summary>
            Convert Money to decimal (same as ToUnit)
            </summary>
            <param name="unit"></param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.Money.ToString">
            <summary>
            Returns a culture invariant string representation of Bitcoin amount
            </summary>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.Money.ToString(System.Boolean,System.Boolean)">
            <summary>
            Returns a culture invariant string representation of Bitcoin amount
            </summary>
            <param name="fplus">True if show + for a positive amount</param>
            <param name="trimExcessZero">True if trim excess zeroes</param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.Money.Almost(NBitcoin.Money,NBitcoin.Money)">
            <summary>
            Tell if amount is almost equal to this instance
            </summary>
            <param name="amount"></param>
            <param name="dust">more or less amount</param>
            <returns>true if equals, else false</returns>
        </member>
        <member name="M:NBitcoin.Money.Almost(NBitcoin.Money,System.Decimal)">
            <summary>
            Tell if amount is almost equal to this instance
            </summary>
            <param name="amount"></param>
            <param name="margin">error margin (between 0 and 1)</param>
            <returns>true if equals, else false</returns>
        </member>
        <member name="M:NBitcoin.Network.CreateBitcoinAddress(System.String)">
            <summary>
            Create a bitcoin address from base58 data, return a BitcoinAddress or BitcoinScriptAddress
            </summary>
            <param name="base58">base58 address</param>
            <exception cref="T:System.FormatException">Invalid base58 address</exception>
            <returns>BitcoinScriptAddress, BitcoinAddress</returns>
        </member>
        <member name="M:NBitcoin.Network.GetNetwork(System.String)">
            <summary>
            Get network from name
            </summary>
            <param name="name">main,mainnet,testnet,test,testnet3,reg,regtest,seg,segnet</param>
            <returns>The network or null of the name does not match any network</returns>
        </member>
        <member name="F:NBitcoin.BuriedDeployments.BIP34">
            <summary>
            Height in coinbase
            </summary>
        </member>
        <member name="F:NBitcoin.BuriedDeployments.BIP65">
            <summary>
            Height in OP_CLTV
            </summary>
        </member>
        <member name="F:NBitcoin.BuriedDeployments.BIP66">
            <summary>
            Strict DER signature
            </summary>
        </member>
        <member name="P:NBitcoin.Consensus.CoinType">
            <summary>
            Specify the BIP44 coin type for this network
            </summary>
        </member>
        <member name="P:NBitcoin.Consensus.LitecoinWorkCalculation">
            <summary>
            Specify using litecoin calculation for difficulty
            </summary>
        </member>
        <member name="M:NBitcoin.NetworkBuilder.BuildAndRegister">
            <summary>
            Create an immutable Network instance, and register it globally so it is queriable through Network.GetNetwork(string name) and Network.GetNetworks().
            </summary>
            <returns></returns>
        </member>
        <member name="T:NBitcoin.NetworkStringParser">
            <summary>
            This class provide a hook for additionnal string format in altcoin network
            </summary>
        </member>
        <member name="M:NBitcoin.NetworkStringParser.TryParse``1(System.String,NBitcoin.Network,``0@)">
            <summary>
            Try to parse a string
            </summary>
            <param name="str">The string to parse</param>
            <param name="result">The result</param>
            <returns>True if it was possible to parse the string</returns>
        </member>
        <member name="T:NBitcoin.OpenAsset.AssetId">
            <summary>
            A unique Id for an asset
            </summary>
        </member>
        <member name="P:NBitcoin.OpenAsset.AssetMoney.Id">
            <summary>
            AssetId of the current amount
            </summary>
        </member>
        <member name="M:NBitcoin.OpenAsset.AssetMoney.Abs">
            <summary>
            Get absolute value of the instance
            </summary>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.OpenAsset.AssetMoney.Split(System.Int32)">
            <summary>
            Split the Money in parts without loss
            </summary>
            <param name="parts">The number of parts (must be more than 0)</param>
            <returns>The splitted money</returns>
        </member>
        <member name="T:NBitcoin.OpenAsset.BitcoinAssetId">
            <summary>
            Base58 representation of an asset id
            </summary>
        </member>
        <member name="T:NBitcoin.OpenAsset.NullColoredTransactionRepository">
            <summary>
            A colored transaction repository which does not save ColoredTransaction
            </summary>
        </member>
        <member name="M:NBitcoin.PartialMerkleTree.Trim(NBitcoin.uint256[])">
            <summary>
            Remove superflous branches
            </summary>
            <param name="transaction"></param>
            <returns></returns>
        </member>
        <member name="T:NBitcoin.Payment.BitcoinUrlBuilder">
            <summary>
            https://github.com/bitcoin/bips/blob/master/bip-0021.mediawiki
            </summary>
        </member>
        <member name="P:NBitcoin.Payment.BitcoinUrlBuilder.PaymentRequestUrl">
            <summary>
            https://github.com/bitcoin/bips/blob/master/bip-0072.mediawiki
            </summary>
        </member>
        <member name="M:NBitcoin.Payment.PaymentMessage.SubmitPayment(System.Uri)">
            <summary>
            Send the payment to given address
            </summary>
            <param name="paymentUrl">ImplicitPaymentUrl if null</param>
            <returns>The PaymentACK</returns>
        </member>
        <member name="P:NBitcoin.Payment.PaymentDetails.Time">
            <summary>
            timestamp (seconds since 1-Jan-1970 UTC) when the PaymentRequest was created.
            </summary>
        </member>
        <member name="P:NBitcoin.Payment.PaymentDetails.Expires">
            <summary>
            timestamp (UTC) after which the PaymentRequest should be considered invalid. 
            </summary>
        </member>
        <member name="P:NBitcoin.Payment.PaymentDetails.Memo">
            <summary>
            plain-text (no formatting) note that should be displayed to the customer, explaining what this PaymentRequest is for. 
            </summary>
        </member>
        <member name="P:NBitcoin.Payment.PaymentDetails.PaymentUrl">
            <summary>
            Secure (usually https) location where a Payment message (see below) may be sent to obtain a PaymentACK. 
            </summary>
        </member>
        <member name="P:NBitcoin.Payment.PaymentRequest.DefaultCertificateServiceProvider">
            <summary>
            Default application wide certificate service provider
            </summary>
        </member>
        <member name="P:NBitcoin.Payment.PaymentRequest.CertificateServiceProvider">
            <summary>
            Instance specific certificate service provider
            </summary>
        </member>
        <member name="M:NBitcoin.Payment.PaymentRequest.Verify">
            <summary>
            Verify that the certificate chain is trusted and signature correct.
            </summary>
            <returns>true if the certificate chain and the signature is trusted or if PKIType == None</returns>
        </member>
        <member name="M:NBitcoin.Payment.WindowsCertificateServiceProvider.GetCertificateName(System.Security.Cryptography.X509Certificates.X509Certificate2)">
            <summary>
            Get the certificate name from the certificate subject
            </summary>
        </member>
        <member name="M:NBitcoin.Policy.ITransactionPolicy.Check(NBitcoin.Transaction,NBitcoin.ICoin[])">
            <summary>
            Check if the given transaction violate the policy
            </summary>
            <param name="transaction">The transaction</param>
            <param name="spentCoins">The previous coins</param>
            <returns>Policy errors</returns>
        </member>
        <member name="T:NBitcoin.Policy.NotEnoughFundsPolicyError">
            <summary>
            Error when not enough funds are present for verifying or building a transaction
            </summary>
        </member>
        <member name="P:NBitcoin.Policy.NotEnoughFundsPolicyError.Missing">
            <summary>
            Amount of Money missing
            </summary>
        </member>
        <member name="P:NBitcoin.Policy.StandardTransactionPolicy.MaxTxFee">
            <summary>
            Safety check, if the FeeRate exceed this value, a policy error is raised
            </summary>
        </member>
        <member name="P:NBitcoin.Policy.StandardTransactionPolicy.CheckMalleabilitySafe">
            <summary>
            Check if the transaction is safe from malleability (default: false)
            </summary>
        </member>
        <member name="P:NBitcoin.Policy.StandardTransactionPolicy.CheckScriptPubKey">
            <summary>
            Check the standardness of scriptPubKey
            </summary>
        </member>
        <member name="T:NBitcoin.Protocol.AddressManager">
            <summary>
            The AddressManager, keep a set of peers discovered on the network in cache can update their actual states.
            Replicate AddressManager of Bitcoin Core, the Buckets and BucketPosition are not guaranteed to be coherent with Bitcoin Core
            </summary>
        </member>
        <member name="M:NBitcoin.Protocol.AddressManager.Select">
            <summary>
            Choose an address to connect to.
            </summary>
            <returns>The network address of a peer, or null if none are found</returns>
        </member>
        <member name="M:NBitcoin.Protocol.AddressManager.GetAddr">
            <summary>
            Return a bunch of addresses, selected at random.
            </summary>
            <returns></returns>
        </member>
        <member name="F:NBitcoin.Protocol.Behaviors.AddressManagerBehaviorMode.None">
            <summary>
            Do not advertize nor discover new peers
            </summary>
        </member>
        <member name="F:NBitcoin.Protocol.Behaviors.AddressManagerBehaviorMode.Advertize">
            <summary>
            Only advertize known peers
            </summary>
        </member>
        <member name="F:NBitcoin.Protocol.Behaviors.AddressManagerBehaviorMode.Discover">
            <summary>
            Only discover peers
            </summary>
        </member>
        <member name="F:NBitcoin.Protocol.Behaviors.AddressManagerBehaviorMode.AdvertizeDiscover">
            <summary>
            Advertize known peer and discover peer
            </summary>
        </member>
        <member name="T:NBitcoin.Protocol.Behaviors.AddressManagerBehavior">
            <summary>
            The AddressManagerBehavior class will respond to getaddr and register advertised nodes from addr messages to the AddressManager.
            The AddressManagerBehavior will also receive feedback about connection attempt and success of discovered peers to the AddressManager, so it can be used later to find valid peer faster.
            </summary>
        </member>
        <member name="F:NBitcoin.Protocol.Behaviors.AddressManagerBehavior._PeersToDiscover">
            <summary>
            The minimum number of peers to discover before trying to connect to a node using the AddressManager (Default: 1000)
            </summary>
        </member>
        <member name="M:NBitcoin.Protocol.Behaviors.BroadcastHub.BroadcastTransactionAsync(NBitcoin.Transaction)">
            <summary>
            Broadcast a transaction on the hub
            </summary>
            <param name="transaction">The transaction to broadcast</param>
            <returns>The cause of the rejection or null</returns>
        </member>
        <member name="P:NBitcoin.Protocol.Behaviors.BroadcastHub.ManualBroadcast">
            <summary>
            If true, the user need to call BroadcastTransactions to ask to the nodes to broadcast it
            </summary>
        </member>
        <member name="M:NBitcoin.Protocol.Behaviors.BroadcastHub.BroadcastTransactions">
            <summary>
            Ask the nodes in the hub to broadcast transactions in the Hub manually
            </summary>
        </member>
        <member name="T:NBitcoin.Protocol.Behaviors.ChainBehavior">
            <summary>
            The Chain Behavior is responsible for keeping a ConcurrentChain up to date with the peer, it also responds to getheaders messages.
            </summary>
        </member>
        <member name="P:NBitcoin.Protocol.Behaviors.ChainBehavior.StripHeader">
            <summary>
            If true, the Chain maintained by the behavior with have its ChainedBlock with no Header (default: false)
            </summary>
        </member>
        <member name="P:NBitcoin.Protocol.Behaviors.ChainBehavior.SkipPoWCheck">
            <summary>
            If true, skip PoW checks (default: false)
            </summary>
        </member>
        <member name="P:NBitcoin.Protocol.Behaviors.ChainBehavior.CanSync">
            <summary>
            Keep the chain in Sync (Default : true)
            </summary>
        </member>
        <member name="P:NBitcoin.Protocol.Behaviors.ChainBehavior.CanRespondToGetHeaders">
            <summary>
            Respond to getheaders messages (Default : true)
            </summary>
        </member>
        <member name="P:NBitcoin.Protocol.Behaviors.ChainBehavior.Synching">
            <summary>
            Using for test, this might not be reliable
            </summary>
        </member>
        <member name="M:NBitcoin.Protocol.Behaviors.ChainBehavior.CheckAnnouncedBlocks">
            <summary>
            Check if any past blocks announced by this peer is in the invalid blocks list, and set InvalidHeaderReceived flag accordingly
            </summary>
            <returns>True if no invalid block is received</returns>
        </member>
        <member name="P:NBitcoin.Protocol.Behaviors.ChainBehavior.AutoSync">
            <summary>
            Sync the chain as headers come from the network (Default : true)
            </summary>
        </member>
        <member name="M:NBitcoin.Protocol.Behaviors.ChainBehavior.TrySync">
            <summary>
            Asynchronously try to sync the chain
            </summary>
        </member>
        <member name="P:NBitcoin.Protocol.Behaviors.ChainBehavior.State.HighestValidatedPoW">
            <summary>
            ChainBehaviors sharing this state will not broadcast headers which are above HighestValidatedPoW
            </summary>
        </member>
        <member name="T:NBitcoin.Protocol.Behaviors.NodesGroupBehavior">
            <summary>
            Maintain connection to a given set of nodes
            </summary>
        </member>
        <member name="T:NBitcoin.Protocol.Behaviors.PingPongBehavior">
            <summary>
            The PingPongBehavior is responsible for firing ping message every PingInterval and responding with pong message, and close the connection if the Ping has not been completed after TimeoutInterval.
            </summary>
        </member>
        <member name="P:NBitcoin.Protocol.Behaviors.PingPongBehavior.Mode">
            <summary>
            Whether the behavior send Ping and respond with Pong (Default : Both)
            </summary>
        </member>
        <member name="P:NBitcoin.Protocol.Behaviors.PingPongBehavior.TimeoutInterval">
            <summary>
            Interval after which an unresponded Ping will result in a disconnection. (Default : 20 minutes)
            </summary>
        </member>
        <member name="P:NBitcoin.Protocol.Behaviors.PingPongBehavior.PingInterval">
            <summary>
            Interval after which a Ping message is fired after the last received Pong (Default : 2 minutes)
            </summary>
        </member>
        <member name="M:NBitcoin.Protocol.Behaviors.PingPongBehavior.Probe">
            <summary>
            Send a ping asynchronously
            </summary>
        </member>
        <member name="T:NBitcoin.Protocol.Filters.INodeFilter">
            <summary>
            A NodeFilter can intercept messages received and sent.
            </summary>
        </member>
        <member name="M:NBitcoin.Protocol.Filters.INodeFilter.OnReceivingMessage(NBitcoin.Protocol.IncomingMessage,System.Action)">
            <summary>
            Intercept a message before it can be processed by listeners
            </summary>
            <param name="message">The message</param>
            <param name="next">The rest of the pipeline</param>
        </member>
        <member name="M:NBitcoin.Protocol.Filters.INodeFilter.OnSendingMessage(NBitcoin.Protocol.Node,NBitcoin.Protocol.Payload,System.Action)">
            <summary>
            Intercept a message before it is sent to the peer
            </summary>
            <param name="node"></param>
            <param name="payload"></param>
            <param name="next">The rest of the pipeline</param>
        </member>
        <member name="F:NBitcoin.Protocol.Message._SkipMagic">
            <summary>
            When parsing, maybe Magic is already parsed
            </summary>
        </member>
        <member name="P:NBitcoin.Protocol.SynchronizeChainOptions.HashStop">
            <summary>
            Location until which synchronization should be stopped (default: null)
            </summary>
        </member>
        <member name="P:NBitcoin.Protocol.SynchronizeChainOptions.SkipPoWCheck">
            <summary>
            Skip PoW check
            </summary>
        </member>
        <member name="P:NBitcoin.Protocol.SynchronizeChainOptions.StripHeaders">
            <summary>
            Strip headers from the retrieved chain
            </summary>
        </member>
        <member name="M:NBitcoin.Protocol.Node.Connect(NBitcoin.Network,NBitcoin.Protocol.AddressManager,NBitcoin.Protocol.NodeConnectionParameters,System.Net.IPEndPoint[])">
            <summary>
            Connect to a random node on the network
            </summary>
            <param name="network">The network to connect to</param>
            <param name="addrman">The addrman used for finding peers</param>
            <param name="parameters">The parameters used by the found node</param>
            <param name="connectedEndpoints">The already connected endpoints, the new endpoint will be select outside of existing groups</param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.Protocol.Node.Connect(NBitcoin.Network,NBitcoin.Protocol.NodeConnectionParameters,System.Net.IPEndPoint[],System.Func{System.Net.IPEndPoint,System.Byte[]})">
            <summary>
            Connect to a random node on the network
            </summary>
            <param name="network">The network to connect to</param>
            <param name="parameters">The parameters used by the found node, use AddressManagerBehavior.GetAddrman for finding peers</param>
            <param name="connectedEndpoints">The already connected endpoints, the new endpoint will be select outside of existing groups</param>
            <param name="getGroup">Group selector, by default NBicoin.IpExtensions.GetGroup</param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.Protocol.Node.ConnectToLocal(NBitcoin.Network,NBitcoin.Protocol.NodeConnectionParameters)">
            <summary>
            Connect to the node of this machine
            </summary>
            <param name="network"></param>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.Protocol.Node.SendMessageAsync(NBitcoin.Protocol.Payload)">
            <summary>
            Send a message to the peer asynchronously
            </summary>
            <param name="payload">The payload to send</param>
            <param name="System.OperationCanceledException.OperationCanceledException">The node has been disconnected</param>
        </member>
        <member name="M:NBitcoin.Protocol.Node.SendMessage(NBitcoin.Protocol.Payload,System.Threading.CancellationToken)">
            <summary>
            Send a message to the peer synchronously
            </summary>
            <param name="payload">The payload to send</param>
            <exception cref="T:System.ArgumentNullException">Payload is null</exception>
            <param name="System.OperationCanceledException.OperationCanceledException">The node has been disconnected, or the cancellation token has been set to canceled</param>
        </member>
        <member name="P:NBitcoin.Protocol.Node.Version">
            <summary>
            The negociated protocol version (minimum of supported version between MyVersion and the PeerVersion)
            </summary>
        </member>
        <member name="P:NBitcoin.Protocol.Node.Advertize">
            <summary>
            Send addr unsollicited message of the AddressFrom peer when passing to Handshaked state
            </summary>
        </member>
        <member name="M:NBitcoin.Protocol.Node.RespondToHandShake(System.Threading.CancellationToken)">
            <summary>
            
            </summary>
            <param name="cancellation"></param>
        </member>
        <member name="P:NBitcoin.Protocol.Node.PreferredTransactionOptions">
            <summary>
            Transaction options we would like
            </summary>
        </member>
        <member name="P:NBitcoin.Protocol.Node.SupportedTransactionOptions">
            <summary>
            Transaction options supported by the peer
            </summary>
        </member>
        <member name="P:NBitcoin.Protocol.Node.ActualTransactionOptions">
            <summary>
            Transaction options we prefer and which is also supported by peer
            </summary>
        </member>
        <member name="M:NBitcoin.Protocol.Node.GetChain(NBitcoin.Protocol.SynchronizeChainOptions,System.Threading.CancellationToken)">
            <summary>
            Get the chain of headers from the peer (thread safe)
            </summary>
            <param name="options">The synchronization chain options</param>
            <param name="cancellationToken"></param>
            <returns>The chain of headers</returns>
        </member>
        <member name="M:NBitcoin.Protocol.Node.GetChain(NBitcoin.uint256,System.Threading.CancellationToken)">
            <summary>
            Get the chain of headers from the peer (thread safe)
            </summary>
            <param name="hashStop">The highest block wanted</param>
            <param name="cancellationToken"></param>
            <returns>The chain of headers</returns>
        </member>
        <member name="M:NBitcoin.Protocol.Node.SynchronizeChain(NBitcoin.ChainBase,NBitcoin.Protocol.SynchronizeChainOptions,System.Threading.CancellationToken)">
            <summary>
            Synchronize a given Chain to the tip of this node if its height is higher. (Thread safe)
            </summary>
            <param name="chain">The chain to synchronize</param>
            <param name="options">The synchronisation options</param>
            <param name="cancellationToken"></param>
            <returns>The chain of block retrieved</returns>
        </member>
        <member name="M:NBitcoin.Protocol.Node.SynchronizeChain(NBitcoin.ChainBase,NBitcoin.uint256,System.Threading.CancellationToken)">
            <summary>
            Synchronize a given Chain to the tip of this node if its height is higher. (Thread safe)
            </summary>
            <param name="chain">The chain to synchronize</param>
            <param name="hashStop">The location until which it synchronize</param>
            <param name="cancellationToken"></param>
            <returns>The chain of block retrieved</returns>
        </member>
        <member name="M:NBitcoin.Protocol.Node.CreateListener">
            <summary>
            Create a listener that will queue messages until diposed
            </summary>
            <returns>The listener</returns>
            <exception cref="T:System.InvalidOperationException">Thrown if used on the listener's thread, as it would result in a deadlock</exception>
        </member>
        <member name="M:NBitcoin.Protocol.Node.GetMempoolTransactions(System.Threading.CancellationToken)">
            <summary>
            Retrieve transactions from the mempool
            </summary>
            <param name="cancellationToken">Cancellation token</param>
            <returns>Transactions in the mempool</returns>
        </member>
        <member name="M:NBitcoin.Protocol.Node.GetMempoolTransactions(NBitcoin.uint256[],System.Threading.CancellationToken)">
            <summary>
            Retrieve transactions from the mempool by ids
            </summary>
            <param name="txIds">Transaction ids to retrieve</param>
            <param name="cancellationToken">Cancellation token</param>
            <returns>The transactions, if a transaction is not found, then it is not returned in the array.</returns>
        </member>
        <member name="M:NBitcoin.Protocol.Node.AddSupportedOptions(NBitcoin.Protocol.InventoryType)">
            <summary>
            Add supported option to the input inventory type
            </summary>
            <param name="inventoryType">Inventory type (like MSG_TX)</param>
            <returns>Inventory type with options (MSG_TX | MSG_WITNESS_FLAG)</returns>
        </member>
        <member name="M:NBitcoin.Protocol.Node.PingPong(System.Threading.CancellationToken)">
            <summary>
            Emit a ping and wait the pong
            </summary>
            <param name="cancellation"></param>
            <returns>Latency</returns>
        </member>
        <member name="P:NBitcoin.Protocol.NodeConnectionParameters.Advertize">
            <summary>
            Send addr unsollicited message of the AddressFrom peer when passing to Handshaked state
            </summary>
        </member>
        <member name="P:NBitcoin.Protocol.NodeConnectionParameters.IsRelay">
            <summary>
            If true, the node will receive all incoming transactions if no bloomfilter are set
            </summary>
        </member>
        <member name="P:NBitcoin.Protocol.NodeConnectionParameters.ReuseBuffer">
            <summary>
            Whether we reuse a 1MB buffer for deserializing messages, for limiting GC activity (Default : true)
            </summary>
        </member>
        <member name="P:NBitcoin.Protocol.NodeServer.InboundNodeConnectionParameters">
            <summary>
            The parameters that will be cloned and applied for each node connecting to the NodeServer
            </summary>
        </member>
        <member name="M:NBitcoin.Protocol.NodesGroup.Connect">
            <summary>
            Start connecting asynchronously to remote peers
            </summary>
        </member>
        <member name="M:NBitcoin.Protocol.NodesGroup.Disconnect">
            <summary>
            Drop connection to all connected nodes
            </summary>
        </member>
        <member name="M:NBitcoin.Protocol.NodesGroup.Purge(System.String)">
            <summary>
            Asynchronously create a new set of nodes
            </summary>
        </member>
        <member name="P:NBitcoin.Protocol.NodesGroup.MaximumNodeConnection">
            <summary>
            The number of node that this behavior will try to maintain online (Default : 8)
            </summary>
        </member>
        <member name="P:NBitcoin.Protocol.NodesGroup.AllowSameGroup">
            <summary>
            If false, the search process will do its best to connect to Node in different network group to prevent sybil attacks. (Default : false)
            If CustomGroupSelector is set, AllowSameGroup is ignored.
            </summary>
        </member>
        <member name="P:NBitcoin.Protocol.NodesGroup.CustomGroupSelector">
            <summary>
            How to calculate a group of an ip, by default using NBitcoin.IpExtensions.GetGroup.
            Overrides AllowSameGroup.
            </summary>
        </member>
        <member name="M:NBitcoin.Protocol.NodesGroup.Dispose">
            <summary>
            Same as Disconnect
            </summary>
        </member>
        <member name="T:NBitcoin.Protocol.AddrPayload">
            <summary>
            An available peer address in the bitcoin network is announce (unsollicited or after a getaddr)
            </summary>
        </member>
        <member name="P:NBitcoin.Protocol.AlertPayload.Now">
            <summary>
            Used for knowing if an alert is valid in past of future
            </summary>
        </member>
        <member name="T:NBitcoin.Protocol.BlockPayload">
            <summary>
            A block received after being asked with a getdata message
            </summary>
        </member>
        <member name="T:NBitcoin.Protocol.FilterLoadPayload">
            <summary>
            Load a bloomfilter in the peer, used by SPV clients
            </summary>
        </member>
        <member name="T:NBitcoin.Protocol.GetAddrPayload">
            <summary>
            Ask for known peer addresses in the network
            </summary>
        </member>
        <member name="T:NBitcoin.Protocol.GetBlocksPayload">
            <summary>
            Ask for the block hashes (inv) that happened since BlockLocators
            </summary>
        </member>
        <member name="T:NBitcoin.Protocol.GetDataPayload">
            <summary>
            Ask for transaction, block or merkle block
            </summary>
        </member>
        <member name="T:NBitcoin.Protocol.GetHeadersPayload">
            <summary>
            Ask block headers that happened since BlockLocators
            </summary>
        </member>
        <member name="T:NBitcoin.Protocol.HeadersPayload">
            <summary>
            Block headers received after a getheaders messages
            </summary>
        </member>
        <member name="T:NBitcoin.Protocol.InvPayload">
            <summary>
            Announce the hash of a transaction or block
            </summary>
        </member>
        <member name="T:NBitcoin.Protocol.MempoolPayload">
            <summary>
            Ask for the mempool, followed by inv messages
            </summary>
        </member>
        <member name="T:NBitcoin.Protocol.MerkleBlockPayload">
            <summary>
            A merkle block received after being asked with a getdata message
            </summary>
        </member>
        <member name="T:NBitcoin.Protocol.NotFoundPayload">
            <summary>
            A getdata message for an asked hash is not found by the remote peer
            </summary>
        </member>
        <member name="T:NBitcoin.Protocol.RejectPayload">
            <summary>
            A transaction or block are rejected being transmitted through tx or block messages
            </summary>
        </member>
        <member name="P:NBitcoin.Protocol.RejectPayload.Message">
            <summary>
            "tx" or "block"
            </summary>
        </member>
        <member name="P:NBitcoin.Protocol.RejectPayload.Reason">
            <summary>
            Details of the error
            </summary>
        </member>
        <member name="P:NBitcoin.Protocol.RejectPayload.Hash">
            <summary>
            The hash being rejected
            </summary>
        </member>
        <member name="T:NBitcoin.Protocol.TxPayload">
            <summary>
            Represents a transaction being sent on the network, is sent after being requested by a getdata (of Transaction or MerkleBlock) message.
            </summary>
        </member>
        <member name="F:NBitcoin.Protocol.NodeServices.Network">
            <summary>
            NODE_NETWORK means that the node is capable of serving the block chain. It is currently
            set by all Bitcoin Core nodes, and is unset by SPV clients or other peers that just want
            network services but don't provide them.
            </summary>
        </member>
        <member name="F:NBitcoin.Protocol.NodeServices.GetUTXO">
            <summary>
             NODE_GETUTXO means the node is capable of responding to the getutxo protocol request.
            Bitcoin Core does not support this but a patch set called Bitcoin XT does.
            See BIP 64 for details on how this is implemented.
            </summary>
        </member>
        <member name="F:NBitcoin.Protocol.NodeServices.NODE_BLOOM">
            <summary> NODE_BLOOM means the node is capable and willing to handle bloom-filtered connections.
            Bitcoin Core nodes used to support this by default, without advertising this bit,
            but no longer do as of protocol version 70011 (= NO_BLOOM_VERSION)
            </summary>
        </member>
        <member name="F:NBitcoin.Protocol.NodeServices.NODE_WITNESS">
            <summary> Indicates that a node can be asked for blocks and transactions including
            witness data. 
            </summary> 
        </member>
        <member name="F:NBitcoin.Protocol.NodeServices.NODE_NETWORK_LIMITED">
            <summary> NODE_NETWORK_LIMITED means the same as NODE_NETWORK with the limitation of only
            serving the last 288 (2 day) blocks
            See BIP159 for details on how this is implemented.
            </summary> 
        </member>
        <member name="P:NBitcoin.Protocol.ProtocolCapabilities.PeerTooOld">
            <summary>
            Disconnect from peers older than this protocol version
            </summary>
        </member>
        <member name="P:NBitcoin.Protocol.ProtocolCapabilities.SupportTimeAddress">
            <summary>
            nTime field added to CAddress, starting with this version;
            if possible, avoid requesting addresses nodes older than this
            </summary>
        </member>
        <member name="P:NBitcoin.Protocol.ProtocolCapabilities.SupportPingPong">
            <summary>
            BIP 0031, pong message, is enabled for all versions AFTER this one
            </summary>
        </member>
        <member name="P:NBitcoin.Protocol.ProtocolCapabilities.SupportMempoolQuery">
            <summary>
            "mempool" command, enhanced "getdata" behavior starts with this version
            </summary>
        </member>
        <member name="P:NBitcoin.Protocol.ProtocolCapabilities.SupportReject">
            <summary>
            "reject" command
            </summary>
        </member>
        <member name="P:NBitcoin.Protocol.ProtocolCapabilities.SupportNodeBloom">
            <summary>
            ! "filter*" commands are disabled without NODE_BLOOM after and including this version
            </summary>
        </member>
        <member name="P:NBitcoin.Protocol.ProtocolCapabilities.SupportSendHeaders">
            <summary>
            ! "sendheaders" command and announcing blocks with headers starts with this version
            </summary>
        </member>
        <member name="P:NBitcoin.Protocol.ProtocolCapabilities.SupportWitness">
            <summary>
            ! Version after which witness support potentially exists
            </summary>
        </member>
        <member name="P:NBitcoin.Protocol.ProtocolCapabilities.SupportCompactBlocks">
            <summary>
            short-id-based block download starts with this version
            </summary>
        </member>
        <member name="P:NBitcoin.Protocol.ProtocolCapabilities.SupportCheckSum">
            <summary>
            Support checksum at p2p message level
            </summary>
        </member>
        <member name="M:NBitcoin.PubKey.#ctor(System.String)">
            <summary>
            Create a new Public key from string
            </summary>
        </member>
        <member name="M:NBitcoin.PubKey.#ctor(System.Byte[])">
            <summary>
            Create a new Public key from byte array
            </summary>
        </member>
        <member name="M:NBitcoin.PubKey.#ctor(System.Byte[],System.Boolean)">
            <summary>
            Create a new Public key from byte array
            </summary>
            <param name="bytes">byte array</param>
            <param name="unsafe">If false, make internal copy of bytes and does perform only a costly check for PubKey format. If true, the bytes array is used as is and only PubKey.Check is used for validating the format. </param>	 
        </member>
        <member name="M:NBitcoin.PubKey.Check(System.Byte[],System.Boolean)">
            <summary>
            Check on public key format.
            </summary>
            <param name="data">bytes array</param>
            <param name="deep">If false, will only check the first byte and length of the array. If true, will also check that the ECC coordinates are correct.</param>
            <returns>true if byte array is valid</returns>
        </member>
        <member name="M:NBitcoin.PubKey.VerifyMessage(System.String,System.String)">
            <summary>
            Verify message signed using signmessage from bitcoincore
            </summary>
            <param name="message">The message</param>
            <param name="signature">The signature</param>
            <returns>True if signatures is valid</returns>
        </member>
        <member name="M:NBitcoin.PubKey.VerifyMessage(System.Byte[],System.String)">
            <summary>
            Verify message signed using signmessage from bitcoincore
            </summary>
            <param name="message">The message</param>
            <param name="signature">The signature</param>
            <returns>True if signatures is valid</returns>
        </member>
        <member name="M:NBitcoin.PubKey.VerifyMessage(System.Byte[],NBitcoin.Crypto.ECDSASignature)">
            <summary>
            Verify message signed using signmessage from bitcoincore
            </summary>
            <param name="message">The message</param>
            <param name="signature">The signature</param>
            <returns>True if signatures is valid</returns>
        </member>
        <member name="M:NBitcoin.PubKey.DecodeSigString(System.String)">
            <summary>
            Decode signature from bitcoincore verify/signing rpc methods
            </summary>
            <param name="signature"></param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.PubKey.GetSharedSecret(NBitcoin.Key)">
            <summary>
            Exchange shared secret through ECDH
            </summary>
            <param name="key">Private key</param>
            <returns>Shared secret</returns>
        </member>
        <member name="M:NBitcoin.PubKey.GetSharedPubkey(NBitcoin.Key)">
            <summary>
            Exchange shared secret through ECDH
            </summary>
            <param name="key">Private key</param>
            <returns>Shared pubkey</returns>
        </member>
        <member name="M:NBitcoin.QBitNinjaTransactionRepository.#ctor(NBitcoin.Network)">
            <summary>
            Use qbitninja public servers
            </summary>
            <param name="network"></param>
        </member>
        <member name="P:NBitcoin.RPC.GetTxOutResponse.BestBlock">
            <summary>
            the block hash
            </summary>
        </member>
        <member name="P:NBitcoin.RPC.GetTxOutResponse.Confirmations">
            <summary>
            The number of confirmations
            </summary>
        </member>
        <member name="P:NBitcoin.RPC.GetTxOutResponse.IsCoinBase">
            <summary>
            Coinbase or not
            </summary>
        </member>
        <member name="P:NBitcoin.RPC.GetTxOutResponse.ScriptPubKeyType">
            <summary>
            The type, eg pubkeyhash
            </summary>
        </member>
        <member name="P:NBitcoin.RPC.ImportMultiAddress.ScriptPubKeyObject.IsAddress">
             <summary>
             Returns true if Address property is populated AND ScriptPubKey is not. If Address and ScriptPubKey are populated, ScriptPubKey takes precedence.
             </summary>
            
        </member>
        <member name="P:NBitcoin.RPC.ImportMultiAddress.Timestamp">
            <summary>
            Creation time of the key, keep null if this address has just been generated
            </summary>
        </member>
        <member name="T:NBitcoin.RPC.ImportMultiScriptPubKeyConverter">
            <summary>
            Custom JsonConverter to deal with loose type of scriptPubKey property in the ImportMulti method
            </summary>
        </member>
        <member name="T:NBitcoin.RPC.RestClient">
            <summary>
            Client class for the unauthenticated REST Interface
            </summary>
        </member>
        <member name="P:NBitcoin.RPC.RestClient.Network">
            <summary>
            Gets the <see cref="P:NBitcoin.RPC.RestClient.Network"/> instance for the client.
            </summary>
        </member>
        <member name="M:NBitcoin.RPC.RestClient.#ctor(System.Uri)">
            <summary>
            Initializes a new instance of the <see cref="T:NBitcoin.RPC.RestClient"/> class.
            </summary>
            <param name="address">The rest API endpoint</param>
            <exception cref="T:System.ArgumentNullException">Null rest API endpoint</exception>
            <exception cref="T:System.ArgumentException">Invalid value for RestResponseFormat</exception>
        </member>
        <member name="M:NBitcoin.RPC.RestClient.#ctor(System.Uri,NBitcoin.Network)">
            <summary>
            Initializes a new instance of the <see cref="T:NBitcoin.RPC.RestClient"/> class.
            </summary>
            <param name="address">The rest API endpoint</param>
            <param name="network">The network to operate with</param>
            <exception cref="T:System.ArgumentNullException">Null rest API endpoint</exception>
            <exception cref="T:System.ArgumentException">Invalid value for RestResponseFormat</exception>
        </member>
        <member name="M:NBitcoin.RPC.RestClient.GetBlockAsync(NBitcoin.uint256)">
            <summary>
            Gets the block.
            </summary>
            <param name="blockId">The block identifier.</param>
            <returns>Given a block hash (id) returns the requested block object.</returns>
            <exception cref="T:System.ArgumentNullException">blockId cannot be null.</exception>
        </member>
        <member name="M:NBitcoin.RPC.RestClient.GetBlock(NBitcoin.uint256)">
            <summary>
            Gets the block.
            </summary>
            <param name="blockId">The block identifier.</param>
            <returns>Given a block hash (id) returns the requested block object.</returns>
            <exception cref="T:System.ArgumentNullException">blockId cannot be null.</exception>
        </member>
        <member name="M:NBitcoin.RPC.RestClient.GetTransactionAsync(NBitcoin.uint256)">
            <summary>
            Gets a transaction.
            </summary>
            <param name="txId">The transaction identifier.</param>
            <returns>Given a transaction hash (id) returns the requested transaction object.</returns>
            <exception cref="T:System.ArgumentNullException">txId cannot be null</exception>
        </member>
        <member name="M:NBitcoin.RPC.RestClient.GetTransaction(NBitcoin.uint256)">
            <summary>
            Gets a transaction.
            </summary>
            <param name="txId">The transaction identifier.</param>
            <returns>Given a transaction hash (id) returns the requested transaction object.</returns>
            <exception cref="T:System.ArgumentNullException">txId cannot be null</exception>
        </member>
        <member name="M:NBitcoin.RPC.RestClient.GetBlockHeadersAsync(NBitcoin.uint256,System.Int32)">
            <summary>
            Gets blocks headers.
            </summary>
            <param name="blockId">The initial block identifier.</param>
            <param name="count">how many headers to get.</param>
            <returns>Given a block hash (blockId) returns as much block headers as specified.</returns>
            <exception cref="T:System.ArgumentNullException">blockId cannot be null</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">count must be greater or equal to one.</exception>
        </member>
        <member name="M:NBitcoin.RPC.RestClient.GetBlockHeaders(NBitcoin.uint256,System.Int32)">
            <summary>
            Gets blocks headers.
            </summary>
            <param name="blockId">The initial block identifier.</param>
            <param name="count">how many headers to get.</param>
            <returns>Given a block hash (blockId) returns as much block headers as specified.</returns>
            <exception cref="T:System.ArgumentNullException">blockId cannot be null</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">count must be greater or equal to one.</exception>
        </member>
        <member name="M:NBitcoin.RPC.RestClient.GetChainInfoAsync">
            <summary>
            Gets the chain information.
            </summary>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.RPC.RestClient.GetUnspentOutputsAsync(System.Collections.Generic.IEnumerable{NBitcoin.OutPoint},System.Boolean)">
            <summary>
            Gets unspect outputs.
            </summary>
            <param name="outPoints">The out points identifiers (TxIn-N).</param>
            <param name="checkMempool">if set to <c>true</c> [check mempool].</param>
            <returns>The unspent transaction outputs (UTXO) for the given outPoints.</returns>
            <exception cref="T:System.ArgumentNullException">outPoints cannot be null.</exception>
        </member>
        <member name="M:NBitcoin.RPC.RPCClient.#ctor(NBitcoin.Network)">
            <summary>
            Use default bitcoin parameters to configure a RPCClient.
            </summary>
            <param name="network">The network used by the node. Must not be null.</param>
        </member>
        <member name="M:NBitcoin.RPC.RPCClient.#ctor(System.String,System.String,NBitcoin.Network)">
            <summary>
            Create a new RPCClient instance
            </summary>
            <param name="authenticationString">username:password, the content of the .cookie file, or cookiefile=pathToCookieFile</param>
            <param name="hostOrUri"></param>
            <param name="network"></param>
        </member>
        <member name="M:NBitcoin.RPC.RPCClient.#ctor(System.String,System.Uri,NBitcoin.Network)">
            <summary>
            Create a new RPCClient instance
            </summary>
            <param name="authenticationString">username:password or the content of the .cookie file or null to auto configure</param>
            <param name="address"></param>
            <param name="network"></param>
        </member>
        <member name="M:NBitcoin.RPC.RPCClient.SendCommand(System.String,System.Object[])">
            <summary>
            Send a command
            </summary>
            <param name="commandName">https://en.bitcoin.it/wiki/Original_Bitcoin_client/API_calls_list</param>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.RPC.RPCClient.SendBatch">
            <summary>
            Send all commands in one batch
            </summary>
        </member>
        <member name="M:NBitcoin.RPC.RPCClient.CancelBatch">
            <summary>
            Cancel all commands
            </summary>
        </member>
        <member name="M:NBitcoin.RPC.RPCClient.SendBatchAsync">
            <summary>
            Send all commands in one batch
            </summary>
        </member>
        <member name="M:NBitcoin.RPC.RPCClient.GetBlockAsync(NBitcoin.uint256)">
            <summary>
            Get the a whole block
            </summary>
            <param name="blockId"></param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.RPC.RPCClient.GetBlock(NBitcoin.uint256)">
            <summary>
            Get the a whole block
            </summary>
            <param name="blockId"></param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.RPC.RPCClient.GetTxOut(NBitcoin.uint256,System.Int32,System.Boolean)">
            <summary>
            Returns details about an unspent transaction output.
            </summary>
            <param name="txid">The transaction id</param>
            <param name="index">vout number</param>
            <param name="includeMempool">Whether to include the mempool. Note that an unspent output that is spent in the mempool won't appear.</param>
            <returns>null if spent or never existed</returns>
        </member>
        <member name="M:NBitcoin.RPC.RPCClient.GetTxOutAsync(NBitcoin.uint256,System.Int32,System.Boolean)">
            <summary>
            Returns details about an unspent transaction output.
            </summary>
            <param name="txid">The transaction id</param>
            <param name="index">vout number</param>
            <param name="includeMempool">Whether to include the mempool. Note that an unspent output that is spent in the mempool won't appear.</param>
            <returns>null if spent or never existed</returns>
        </member>
        <member name="M:NBitcoin.RPC.RPCClient.GetTransactions(NBitcoin.uint256)">
            <summary>
            GetTransactions only returns on txn which are not entirely spent unless you run bitcoinq with txindex=1.
            </summary>
            <param name="blockHash"></param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.RPC.RPCClient.GetRawTransaction(NBitcoin.uint256,System.Boolean)">
            <summary>
            getrawtransaction only returns on txn which are not entirely spent unless you run bitcoinq with txindex=1.
            </summary>
            <param name="txid"></param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.RPC.RPCClient.EstimateSmartFee(System.Int32,NBitcoin.RPC.EstimateSmartFeeMode)">
            <summary>
            (>= Bitcoin Core v0.14) Get the estimated fee per kb for being confirmed in nblock
            </summary>
            <param name="confirmationTarget">Confirmation target in blocks (1 - 1008)</param>
            <param name="estimateMode">Whether to return a more conservative estimate which also satisfies a longer history. A conservative estimate potentially returns a higher feerate and is more likely to be sufficient for the desired target, but is not as responsive to short term drops in the prevailing fee market.</param>
            <returns>The estimated fee rate, block number where estimate was found</returns>
            <exception cref="T:NBitcoin.RPC.NoEstimationException">The Fee rate couldn't be estimated because of insufficient data from Bitcoin Core</exception>
        </member>
        <member name="M:NBitcoin.RPC.RPCClient.TryEstimateSmartFeeAsync(System.Int32,NBitcoin.RPC.EstimateSmartFeeMode)">
            <summary>
            (>= Bitcoin Core v0.14) Tries to get the estimated fee per kb for being confirmed in nblock
            </summary>
            <param name="confirmationTarget">Confirmation target in blocks (1 - 1008)</param>
            <param name="estimateMode">Whether to return a more conservative estimate which also satisfies a longer history. A conservative estimate potentially returns a higher feerate and is more likely to be sufficient for the desired target, but is not as responsive to short term drops in the prevailing fee market.</param>
            <returns>The estimated fee rate, block number where estimate was found or null</returns>
        </member>
        <member name="M:NBitcoin.RPC.RPCClient.TryEstimateSmartFee(System.Int32,NBitcoin.RPC.EstimateSmartFeeMode)">
            <summary>
            (>= Bitcoin Core v0.14) Tries to get the estimated fee per kb for being confirmed in nblock
            </summary>
            <param name="confirmationTarget">Confirmation target in blocks (1 - 1008)</param>
            <param name="estimateMode">Whether to return a more conservative estimate which also satisfies a longer history. A conservative estimate potentially returns a higher feerate and is more likely to be sufficient for the desired target, but is not as responsive to short term drops in the prevailing fee market.</param>
            <returns>The estimated fee rate, block number where estimate was found or null</returns>
        </member>
        <member name="M:NBitcoin.RPC.RPCClient.EstimateSmartFeeAsync(System.Int32,NBitcoin.RPC.EstimateSmartFeeMode)">
            <summary>
            (>= Bitcoin Core v0.14) Get the estimated fee per kb for being confirmed in nblock
            </summary>
            <param name="confirmationTarget">Confirmation target in blocks (1 - 1008)</param>
            <param name="estimateMode">Whether to return a more conservative estimate which also satisfies a longer history. A conservative estimate potentially returns a higher feerate and is more likely to be sufficient for the desired target, but is not as responsive to short term drops in the prevailing fee market.</param>
            <returns>The estimated fee rate, block number where estimate was found</returns>
            <exception cref="T:NBitcoin.RPC.NoEstimationException">when fee couldn't be estimated</exception>
        </member>
        <member name="M:NBitcoin.RPC.RPCClient.EstimateSmartFeeImplAsync(System.Int32,NBitcoin.RPC.EstimateSmartFeeMode)">
            <summary>
            (>= Bitcoin Core v0.14)
            </summary>
        </member>
        <member name="M:NBitcoin.RPC.RPCClient.SendToAddress(NBitcoin.BitcoinAddress,NBitcoin.Money,System.String,System.String,System.Boolean,System.Boolean)">
            <summary>
            Requires wallet support. Requires an unlocked wallet or an unencrypted wallet.
            </summary>
            <param name="address">A P2PKH or P2SH address to which the bitcoins should be sent</param>
            <param name="amount">The amount to spend</param>
            <param name="commentTx">A locally-stored (not broadcast) comment assigned to this transaction. Default is no comment</param>
            <param name="commentDest">A locally-stored (not broadcast) comment assigned to this transaction. Meant to be used for describing who the payment was sent to. Default is no comment</param>
            <param name="subtractFeeFromAmount">The fee will be deducted from the amount being sent. The recipient will receive less bitcoins than you enter in the amount field. </param>
            <param name="replaceable">Allow this transaction to be replaced by a transaction with higher fees. </param>
            <returns>The TXID of the sent transaction</returns>
        </member>
        <member name="M:NBitcoin.RPC.RPCClient.SendToAddressAsync(NBitcoin.BitcoinAddress,NBitcoin.Money,System.String,System.String,System.Boolean,System.Boolean)">
            <summary>
            Requires wallet support. Requires an unlocked wallet or an unencrypted wallet.
            </summary>
            <param name="address">A P2PKH or P2SH address to which the bitcoins should be sent</param>
            <param name="amount">The amount to spend</param>
            <param name="commentTx">A locally-stored (not broadcast) comment assigned to this transaction. Default is no comment</param>
            <param name="commentDest">A locally-stored (not broadcast) comment assigned to this transaction. Meant to be used for describing who the payment was sent to. Default is no comment</param>
            <param name="subtractFeeFromAmount">The fee will be deducted from the amount being sent. The recipient will receive less bitcoins than you enter in the amount field. </param>
            <param name="replaceable">Allow this transaction to be replaced by a transaction with higher fees. </param>
            <returns>The TXID of the sent transaction</returns>
        </member>
        <member name="M:NBitcoin.RPC.RPCClient.InvalidateBlock(NBitcoin.uint256)">
            <summary>
            Permanently marks a block as invalid, as if it violated a consensus rule.
            </summary>
            <param name="blockhash">the hash of the block to mark as invalid</param>
        </member>
        <member name="M:NBitcoin.RPC.RPCClient.InvalidateBlockAsync(NBitcoin.uint256)">
            <summary>
            Permanently marks a block as invalid, as if it violated a consensus rule.
            </summary>
            <param name="blockhash">the hash of the block to mark as invalid</param>
        </member>
        <member name="M:NBitcoin.RPC.RPCClient.AbandonTransaction(NBitcoin.uint256)">
            <summary>
            Marks a transaction and all its in-wallet descendants as abandoned which will allow
            for their inputs to be respent.
            </summary>
            <param name="txId">the transaction id to be marked as abandoned.</param>
        </member>
        <member name="M:NBitcoin.RPC.RPCClient.AbandonTransactionAsync(NBitcoin.uint256)">
            <summary>
            Marks a transaction and all its in-wallet descendants as abandoned which will allow
            for their inputs to be respent.
            </summary>
            <param name="txId">the transaction id to be marked as abandoned.</param>
        </member>
        <member name="M:NBitcoin.RPC.RPCClient.GetAddressesByAccount(System.String)">
            <summary>
            Returns a list of every address assigned to a particular account.
            </summary>
            <param name="account">
            The name of the account containing the addresses to get. To get addresses from the default account, 
            pass an empty string ("").
            </param>
            <returns>
            A collection of all addresses belonging to the specified account. 
            If the account has no addresses, the collection will be empty
            </returns>
        </member>
        <member name="M:NBitcoin.RPC.RPCClient.GetReceivedByAddress(NBitcoin.BitcoinAddress)">
            <summary>
            Returns the total amount received by the specified address in transactions with at 
            least one (default) confirmations. It does not count coinbase transactions.
            </summary>
            <param name="address">The address whose transactions should be tallied.</param>
            <returns>The number of bitcoins received by the address, excluding coinbase transactions. May be 0.</returns>
        </member>
        <member name="M:NBitcoin.RPC.RPCClient.GetReceivedByAddressAsync(NBitcoin.BitcoinAddress)">
            <summary>
            Returns the total amount received by the specified address in transactions with at 
            least one (default) confirmations. It does not count coinbase transactions.
            </summary>
            <param name="address">The address whose transactions should be tallied.</param>
            <returns>The number of bitcoins received by the address, excluding coinbase transactions. May be 0.</returns>
        </member>
        <member name="M:NBitcoin.RPC.RPCClient.GetReceivedByAddress(NBitcoin.BitcoinAddress,System.Int32)">
            <summary>
            Returns the total amount received by the specified address in transactions with the 
            specified number of confirmations. It does not count coinbase transactions.
            </summary>
            <param name="confirmations">
            The minimum number of confirmations an externally-generated transaction must have before 
            it is counted towards the balance. Transactions generated by this node are counted immediately. 
            Typically, externally-generated transactions are payments to this wallet and transactions 
            generated by this node are payments to other wallets. Use 0 to count unconfirmed transactions. 
            Default is 1.
            </param>
            <returns>The number of bitcoins received by the address, excluding coinbase transactions. May be 0.</returns>
        </member>
        <member name="M:NBitcoin.RPC.RPCClient.GetReceivedByAddressAsync(NBitcoin.BitcoinAddress,System.Int32)">
            <summary>
            Returns the total amount received by the specified address in transactions with the 
            specified number of confirmations. It does not count coinbase transactions.
            </summary>
            <param name="confirmations">
            The minimum number of confirmations an externally-generated transaction must have before 
            it is counted towards the balance. Transactions generated by this node are counted immediately. 
            Typically, externally-generated transactions are payments to this wallet and transactions 
            generated by this node are payments to other wallets. Use 0 to count unconfirmed transactions. 
            Default is 1.
            </param>
            <returns>The number of bitcoins received by the address, excluding coinbase transactions. May be 0.</returns>
        </member>
        <member name="M:NBitcoin.RPC.RPCClient.ListAccounts">
            <summary>
            Lists accounts and their balances, with the default number of confirmations for balances (1), 
            and not including watch only addresses (default false).
            </summary>
        </member>
        <member name="M:NBitcoin.RPC.RPCClient.ListAccounts(System.Int32)">
            <summary>
            Lists accounts and their balances, based on the specified number of confirmations.
            </summary>
            <param name="confirmations">
            The minimum number of confirmations an externally-generated transaction must have before 
            it is counted towards the balance. Transactions generated by this node are counted immediately. 
            Typically, externally-generated transactions are payments to this wallet and transactions 
            generated by this node are payments to other wallets. Use 0 to count unconfirmed transactions. 
            Default is 1.
            </param>
            <returns>
            A list of accounts and their balances.
            </returns>
        </member>
        <member name="M:NBitcoin.RPC.RPCClient.ListAccounts(System.Int32,System.Boolean)">
            <summary>
            Lists accounts and their balances, based on the specified number of confirmations, 
            and including watch only accounts if specified. (Added in Bitcoin Core 0.10.0)
            </summary>
            <param name="confirmations">
            The minimum number of confirmations an externally-generated transaction must have before 
            it is counted towards the balance. Transactions generated by this node are counted immediately. 
            Typically, externally-generated transactions are payments to this wallet and transactions 
            generated by this node are payments to other wallets. Use 0 to count unconfirmed transactions. 
            Default is 1.
            </param>
            <param name="includeWatchOnly">
            If set to true, include watch-only addresses in details and calculations as if they were 
            regular addresses belonging to the wallet. If set to false (the default), treat watch-only 
            addresses as if they didn’t belong to this wallet.
            </param>
            <returns>
            A list of accounts and their balances.
            </returns>
        </member>
        <member name="M:NBitcoin.RPC.RPCClient.ListUnspent">
            <summary>
            Returns an array of unspent transaction outputs belonging to this wallet. 
            </summary>
            <remarks>
            <para>
            Note: as of Bitcoin Core 0.10.0, outputs affecting watch-only addresses will be returned; 
            see the spendable field in the results.
            </para>
            </remarks>
        </member>
        <member name="M:NBitcoin.RPC.RPCClient.ListUnspent(System.Int32,System.Int32,NBitcoin.BitcoinAddress[])">
            <summary>
            Returns an array of unspent transaction outputs belonging to this wallet,
            specifying the minimum and maximum number of confirmations to include,
            and the list of addresses to include. 
            </summary>
        </member>
        <member name="M:NBitcoin.RPC.RPCClient.ListUnspentAsync">
            <summary>
            Returns an array of unspent transaction outputs belonging to this wallet. 
            </summary>
        </member>
        <member name="M:NBitcoin.RPC.RPCClient.ListUnspentAsync(System.Int32,System.Int32,NBitcoin.BitcoinAddress[])">
            <summary>
            Returns an array of unspent transaction outputs belonging to this wallet,
            specifying the minimum and maximum number of confirmations to include,
            and the list of addresses to include. 
            </summary>
        </member>
        <member name="M:NBitcoin.RPC.RPCClient.WalletPassphrase(System.String,System.Int32)">
            <summary>
            The walletpassphrase RPC stores the wallet decryption key in memory for the indicated number of seconds.Issuing the walletpassphrase command while the wallet is already unlocked will set a new unlock time that overrides the old one.
            </summary>
            <param name="passphrase">The passphrase</param>
            <param name="timeout">Timeout in seconds</param>
        </member>
        <member name="M:NBitcoin.RPC.RPCClient.WalletPassphraseAsync(System.String,System.Int32)">
            <summary>
            The walletpassphrase RPC stores the wallet decryption key in memory for the indicated number of seconds.Issuing the walletpassphrase command while the wallet is already unlocked will set a new unlock time that overrides the old one.
            </summary>
            <param name="passphrase">The passphrase</param>
            <param name="timeout">Timeout in seconds</param>
        </member>
        <member name="M:NBitcoin.RPC.RPCClient.SignRawTransaction(NBitcoin.Transaction)">
            <summary>
            Sign a transaction
            </summary>
            <param name="tx">The transaction to be signed</param>
            <returns>The signed transaction</returns>
        </member>
        <member name="M:NBitcoin.RPC.RPCClient.SignRawTransactionAsync(NBitcoin.Transaction)">
            <summary>
            Sign a transaction
            </summary>
            <param name="tx">The transaction to be signed</param>
            <returns>The signed transaction</returns>
        </member>
        <member name="P:NBitcoin.RPC.RPCCredentialString.UseDefault">
            <summary>
            Use default connection settings of the chain
            </summary>
        </member>
        <member name="P:NBitcoin.RPC.RPCCredentialString.WalletName">
            <summary>
            Name of the wallet in multi wallet mode
            </summary>
        </member>
        <member name="P:NBitcoin.RPC.RPCCredentialString.CookieFile">
            <summary>
            Path to cookie file
            </summary>
        </member>
        <member name="P:NBitcoin.RPC.RPCCredentialString.UserPassword">
            <summary>
            Username and password
            </summary>
        </member>
        <member name="T:NBitcoin.RPC.RPCErrorCode">
            <summary>
            RPC error code thrown by the <see cref="T:NBitcoin.RPC.RPCClient"/>
            </summary>
        </member>
        <member name="F:NBitcoin.RPC.RPCErrorCode.RPC_INVALID_REQUEST">
            <summary>
            RPC_INVALID_REQUEST is internally mapped to HTTP_BAD_REQUEST (400).
            It should not be used for application-layer errors. 
            </summary>
        </member>
        <member name="F:NBitcoin.RPC.RPCErrorCode.RPC_METHOD_NOT_FOUND">
            <summary>
            RPC_METHOD_NOT_FOUND is internally mapped to HTTP_NOT_FOUND (404).
            It should not be used for application-layer errors.
            </summary>
        </member>
        <member name="F:NBitcoin.RPC.RPCErrorCode.RPC_INTERNAL_ERROR">
            <summary>
            RPC_INTERNAL_ERROR should only be used for genuine errors in bitcoind
            (for example datadir corruption).
            </summary>
        </member>
        <member name="F:NBitcoin.RPC.RPCErrorCode.RPC_MISC_ERROR">
            <summary>
            std::exception thrown in command handling
            </summary>
        </member>
        <member name="F:NBitcoin.RPC.RPCErrorCode.RPC_FORBIDDEN_BY_SAFE_MODE">
            <summary>
            Server is in safe mode, and command is not allowed in safe mode
            </summary>
        </member>
        <member name="F:NBitcoin.RPC.RPCErrorCode.RPC_TYPE_ERROR">
            <summary>
            Unexpected type was passed as parameter
            </summary>
        </member>
        <member name="F:NBitcoin.RPC.RPCErrorCode.RPC_INVALID_ADDRESS_OR_KEY">
            <summary>
            Invalid address or key
            </summary>
        </member>
        <member name="F:NBitcoin.RPC.RPCErrorCode.RPC_OUT_OF_MEMORY">
            <summary>
            Ran out of memory during operation
            </summary>
        </member>
        <member name="F:NBitcoin.RPC.RPCErrorCode.RPC_INVALID_PARAMETER">
            <summary>
            Invalid, missing or duplicate parameter
            </summary>
        </member>
        <member name="F:NBitcoin.RPC.RPCErrorCode.RPC_DATABASE_ERROR">
            <summary>
            Database error
            </summary>
        </member>
        <member name="F:NBitcoin.RPC.RPCErrorCode.RPC_DESERIALIZATION_ERROR">
            <summary>
            Error parsing or validating structure in raw format
            </summary>
        </member>
        <member name="F:NBitcoin.RPC.RPCErrorCode.RPC_VERIFY_ERROR">
            <summary>
            General error during transaction or block submission
            </summary>
        </member>
        <member name="F:NBitcoin.RPC.RPCErrorCode.RPC_VERIFY_REJECTED">
            <summary>
            Transaction or block was rejected by network rules
            </summary>
        </member>
        <member name="F:NBitcoin.RPC.RPCErrorCode.RPC_VERIFY_ALREADY_IN_CHAIN">
            <summary>
            Transaction already in chain
            </summary>
        </member>
        <member name="F:NBitcoin.RPC.RPCErrorCode.RPC_IN_WARMUP">
            <summary>
            Client still warming up
            </summary>
        </member>
        <member name="F:NBitcoin.RPC.RPCErrorCode.RPC_METHOD_DEPRECATED">
            <summary>
            RPC method is deprecated
            </summary>
        </member>
        <member name="F:NBitcoin.RPC.RPCErrorCode.RPC_CLIENT_NOT_CONNECTED">
            <summary>
            Bitcoin is not connected
            </summary>
        </member>
        <member name="F:NBitcoin.RPC.RPCErrorCode.RPC_CLIENT_IN_INITIAL_DOWNLOAD">
            <summary>
            Still downloading initial blocks
            </summary>
        </member>
        <member name="F:NBitcoin.RPC.RPCErrorCode.RPC_CLIENT_NODE_ALREADY_ADDED">
            <summary>
            Node is already added
            </summary>
        </member>
        <member name="F:NBitcoin.RPC.RPCErrorCode.RPC_CLIENT_NODE_NOT_ADDED">
            <summary>
            Node has not been added before
            </summary>
        </member>
        <member name="F:NBitcoin.RPC.RPCErrorCode.RPC_CLIENT_NODE_NOT_CONNECTED">
            <summary>
            Node to disconnect not found in connected nodes
            </summary>
        </member>
        <member name="F:NBitcoin.RPC.RPCErrorCode.RPC_CLIENT_INVALID_IP_OR_SUBNET">
            <summary>
            Invalid IP/Subnet
            </summary>
        </member>
        <member name="F:NBitcoin.RPC.RPCErrorCode.RPC_CLIENT_P2P_DISABLED">
            <summary>
            No valid connection manager instance found
            </summary>
        </member>
        <member name="F:NBitcoin.RPC.RPCErrorCode.RPC_WALLET_ERROR">
            <summary>
            Unspecified problem with wallet (key not found etc.)
            </summary>
        </member>
        <member name="F:NBitcoin.RPC.RPCErrorCode.RPC_WALLET_INSUFFICIENT_FUNDS">
            <summary>
            Not enough funds in wallet or account
            </summary>
        </member>
        <member name="F:NBitcoin.RPC.RPCErrorCode.RPC_WALLET_INVALID_ACCOUNT_NAME">
            <summary>
            Invalid account name
            </summary>
        </member>
        <member name="F:NBitcoin.RPC.RPCErrorCode.RPC_WALLET_KEYPOOL_RAN_OUT">
            <summary>
            Keypool ran out, call keypoolrefill first
            </summary>
        </member>
        <member name="F:NBitcoin.RPC.RPCErrorCode.RPC_WALLET_UNLOCK_NEEDED">
            <summary>
            Enter the wallet passphrase with walletpassphrase first
            </summary>
        </member>
        <member name="F:NBitcoin.RPC.RPCErrorCode.RPC_WALLET_PASSPHRASE_INCORRECT">
            <summary>
            The wallet passphrase entered was incorrect
            </summary>
        </member>
        <member name="F:NBitcoin.RPC.RPCErrorCode.RPC_WALLET_WRONG_ENC_STATE">
            <summary>
            Command given in wrong wallet encryption state (encrypting an encrypted wallet etc.)
            </summary>
        </member>
        <member name="F:NBitcoin.RPC.RPCErrorCode.RPC_WALLET_ENCRYPTION_FAILED">
            <summary>
            Failed to encrypt the wallet
            </summary>
        </member>
        <member name="F:NBitcoin.RPC.RPCErrorCode.RPC_WALLET_ALREADY_UNLOCKED">
            <summary>
            Wallet is already unlocked
            </summary>
        </member>
        <member name="F:NBitcoin.RPC.RPCErrorCode.RPC_WALLET_NOT_FOUND">
            <summary>
            Invalid wallet specified
            </summary>
        </member>
        <member name="F:NBitcoin.RPC.RPCErrorCode.RPC_WALLET_NOT_SPECIFIED">
            <summary>
            No wallet specified (error when there are multiple wallets loaded)
            </summary>
        </member>
        <member name="T:NBitcoin.ScriptVerify">
            <summary>
            Script verification flags
            </summary>
        </member>
        <member name="F:NBitcoin.ScriptVerify.P2SH">
            <summary>
            Evaluate P2SH subscripts (softfork safe, BIP16).
            </summary>
        </member>
        <member name="F:NBitcoin.ScriptVerify.StrictEnc">
            <summary>
            Passing a non-strict-DER signature or one with undefined hashtype to a checksig operation causes script failure.
            Passing a pubkey that is not (0x04 + 64 bytes) or (0x02 or 0x03 + 32 bytes) to checksig causes that pubkey to be
            +
            skipped (not softfork safe: this flag can widen the validity of OP_CHECKSIG OP_NOT).
            </summary>
        </member>
        <member name="F:NBitcoin.ScriptVerify.DerSig">
            <summary>
            Passing a non-strict-DER signature to a checksig operation causes script failure (softfork safe, BIP62 rule 1)
            </summary>
        </member>
        <member name="F:NBitcoin.ScriptVerify.LowS">
            <summary>
            Passing a non-strict-DER signature or one with S > order/2 to a checksig operation causes script failure
            (softfork safe, BIP62 rule 5).
            </summary>
        </member>
        <member name="F:NBitcoin.ScriptVerify.NullDummy">
            <summary>
            verify dummy stack item consumed by CHECKMULTISIG is of zero-length (softfork safe, BIP62 rule 7).
            </summary>
        </member>
        <member name="F:NBitcoin.ScriptVerify.SigPushOnly">
            <summary>
            Using a non-push operator in the scriptSig causes script failure (softfork safe, BIP62 rule 2).
            </summary>
        </member>
        <member name="F:NBitcoin.ScriptVerify.MinimalData">
            <summary>
            Require minimal encodings for all push operations (OP_0... OP_16, OP_1NEGATE where possible, direct
            pushes up to 75 bytes, OP_PUSHDATA up to 255 bytes, OP_PUSHDATA2 for anything larger). Evaluating
            any other push causes the script to fail (BIP62 rule 3).
            In addition, whenever a stack element is interpreted as a number, it must be of minimal length (BIP62 rule 4).
            (softfork safe)
            </summary>
        </member>
        <member name="F:NBitcoin.ScriptVerify.DiscourageUpgradableNops">
             <summary>
             Discourage use of NOPs reserved for upgrades (NOP1-10)
            
             Provided so that nodes can avoid accepting or mining transactions
             containing executed NOP's whose meaning may change after a soft-fork,
             thus rendering the script invalid; with this flag set executing
             discouraged NOPs fails the script. This verification flag will never be
             a mandatory flag applied to scripts in a block. NOPs that are not
             executed, e.g.  within an unexecuted IF ENDIF block, are *not* rejected.
             </summary>
        </member>
        <member name="F:NBitcoin.ScriptVerify.CleanStack">
            <summary>
            Require that only a single stack element remains after evaluation. This changes the success criterion from
            "At least one stack element must remain, and when interpreted as a boolean, it must be true" to
            "Exactly one stack element must remain, and when interpreted as a boolean, it must be true".
            (softfork safe, BIP62 rule 6)
            Note: CLEANSTACK should never be used without P2SH.
            </summary>
        </member>
        <member name="F:NBitcoin.ScriptVerify.CheckLockTimeVerify">
             <summary>
             Verify CHECKLOCKTIMEVERIFY
            
             See BIP65 for details.
             </summary>
        </member>
        <member name="F:NBitcoin.ScriptVerify.CheckSequenceVerify">
            <summary>
            See BIP68 for details.
            </summary>
        </member>
        <member name="F:NBitcoin.ScriptVerify.Witness">
            <summary>
            Support segregated witness
            </summary>
        </member>
        <member name="F:NBitcoin.ScriptVerify.DiscourageUpgradableWitnessProgram">
            <summary>
            Making v2-v16 witness program non-standard
            </summary>
        </member>
        <member name="F:NBitcoin.ScriptVerify.MinimalIf">
            <summary>
            Segwit script only: Require the argument of OP_IF/NOTIF to be exactly 0x01 or empty vector
            </summary>
        </member>
        <member name="F:NBitcoin.ScriptVerify.NullFail">
            <summary>
            Signature(s) must be empty vector if an CHECK(MULTI)SIG operation failed
            </summary>
        </member>
        <member name="F:NBitcoin.ScriptVerify.WitnessPubkeyType">
            <summary>
            Public keys in segregated witness scripts must be compressed
            </summary>
        </member>
        <member name="F:NBitcoin.ScriptVerify.ForkId">
            <summary>
            Some altcoins like BCash and BGold requires ForkId inside the sigHash
            </summary>
        </member>
        <member name="F:NBitcoin.ScriptVerify.Mandatory">
            <summary>
            Mandatory script verification flags that all new blocks must comply with for
            them to be valid. (but old blocks may not comply with) Currently just P2SH,
            but in the future other flags may be added, such as a soft-fork to enforce
            strict DER encoding.
            
            Failing one of these tests may trigger a DoS ban - see CheckInputs() for
            details.
            </summary>
        </member>
        <member name="F:NBitcoin.ScriptVerify.Standard">
            <summary>
            Standard script verification flags that standard transactions will comply
            with. However scripts violating these flags may still be present in valid
            blocks and we must accept those blocks.
            </summary>
        </member>
        <member name="T:NBitcoin.SigHash">
            <summary>
            Signature hash types/flags
            </summary>
        </member>
        <member name="F:NBitcoin.SigHash.All">
            <summary>
            All outputs are signed
            </summary>
        </member>
        <member name="F:NBitcoin.SigHash.None">
            <summary>
            No outputs as signed
            </summary>
        </member>
        <member name="F:NBitcoin.SigHash.Single">
            <summary>
            Only the output with the same index as this input is signed
            </summary>
        </member>
        <member name="F:NBitcoin.SigHash.AnyoneCanPay">
            <summary>
            If set, no inputs, except this, are part of the signature
            </summary>
        </member>
        <member name="T:NBitcoin.OpcodeType">
            <summary>
            Script opcodes
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NBitcoin.Script.ExtractScriptCode(System.Int32)" -->
        <member name="P:NBitcoin.Script.PaymentScript">
            <summary>
            Get the P2SH scriptPubKey of this script
            </summary>
        </member>
        <member name="P:NBitcoin.Script.IsWitness">
            <summary>
            True if the scriptPubKey is witness
            </summary>
        </member>
        <member name="M:NBitcoin.Script.GetSignerAddress(NBitcoin.Network)">
            <summary>
            Extract P2SH or P2PH address from scriptSig
            </summary>
            <param name="network">The network</param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.Script.GetSigner">
            <summary>
            Extract P2SH or P2PH id from scriptSig
            </summary>
            <returns>The network</returns>
        </member>
        <member name="M:NBitcoin.Script.GetDestinationAddress(NBitcoin.Network)">
            <summary>
            Extract P2SH/P2PH/P2WSH/P2WPKH address from scriptPubKey
            </summary>
            <param name="network"></param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.Script.GetDestination">
            <summary>
            Extract P2SH/P2PH/P2WSH/P2WPKH id from scriptPubKey
            </summary>
            <param name="network"></param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.Script.GetDestinationPublicKeys">
            <summary>
            Extract public keys if this script is a multi sig or pay to pub key scriptPubKey
            </summary>
            <param name="network"></param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.Script.ToRawScript">
            <summary>
            Get script byte array
            </summary>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.Script.ToBytes">
            <summary>
            Get script byte array
            </summary>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.Script.ToRawScript(System.Boolean)">
            <summary>
            Get script byte array
            </summary>
            <param name="unsafe">if false, returns a copy of the internal byte array</param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.Script.ToBytes(System.Boolean)">
            <summary>
            Get script byte array
            </summary>
            <param name="unsafe">if false, returns a copy of the internal byte array</param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.ScriptEvaluationContext.CScriptNum.#ctor(System.Int64)">
            Numeric opcodes (OP_1ADD, etc) are restricted to operating on 4-byte integers.
            The semantics are subtle, though: operands must be in the range [-2^31 +1...2^31 -1],
            but results may overflow (and are valid as long as they are not used in a subsequent
            numeric operation). CScriptNum enforces those semantics by storing results as
            an int64 and allowing out-of-range values to be returned as a vector of bytes but
            throwing an exception if arithmetic is done or the result is interpreted as an integer.
        </member>
        <member name="T:NBitcoin.ContextStack`1">
            <summary>
            ContextStack is used internally by the bitcoin script evaluator. This class contains
            operations not typically available in a "pure" Stack class, as example:
            Insert, Swap, Erase and Top (Peek w/index)
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:NBitcoin.ContextStack`1.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:NBitcoin.ContextStack`1"/> class.
            </summary>
        </member>
        <member name="M:NBitcoin.ContextStack`1.#ctor(NBitcoin.ContextStack{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:NBitcoin.ContextStack`1"/> 
            base on another stack. This is for copy/clone. 
            </summary>
            <param name="stack">The stack.</param>
        </member>
        <member name="P:NBitcoin.ContextStack`1.Count">
            <summary>
            Gets the number of items in the stack.
            </summary>
        </member>
        <member name="M:NBitcoin.ContextStack`1.Push(`0)">
            <summary>
            Pushes the specified item on the stack.
            </summary>
            <param name="item">The item to by pushed.</param>
        </member>
        <member name="M:NBitcoin.ContextStack`1.Pop">
            <summary>
            Pops this element in top of the stack.
            </summary>
            <returns>The element in top of the stack</returns>
        </member>
        <member name="M:NBitcoin.ContextStack`1.Clear(System.Int32)">
            <summary>
            Pops as many items as specified.
            </summary>
            <param name="n">The number of items to be poped</param>
            <exception cref="T:System.ArgumentOutOfRangeException">Cannot remove more elements</exception>
        </member>
        <member name="M:NBitcoin.ContextStack`1.Top(System.Int32)">
            <summary>
            Returns the i-th element from the top of the stack.
            </summary>
            <param name="i">The i-th index.</param>
            <returns>the i-th element from the top of the stack</returns>
            <exception cref="T:System.IndexOutOfRangeException">topIndex</exception>
        </member>
        <member name="M:NBitcoin.ContextStack`1.Swap(System.Int32,System.Int32)">
            <summary>
            Swaps the specified i and j elements in the stack.
            </summary>
            <param name="i">The i-th index.</param>
            <param name="j">The j-th index.</param>
            <exception cref="T:System.IndexOutOfRangeException">
            i or  j
            </exception>
        </member>
        <member name="M:NBitcoin.ContextStack`1.Insert(System.Int32,`0)">
            <summary>
            Inserts an item in the specified position.
            </summary>
            <param name="position">The position.</param>
            <param name="value">The value.</param>
        </member>
        <member name="M:NBitcoin.ContextStack`1.Remove(System.Int32)">
            <summary>
            Removes the i-th item.
            </summary>
            <param name="from">The item position</param>
        </member>
        <member name="M:NBitcoin.ContextStack`1.Remove(System.Int32,System.Int32)">
            <summary>
            Removes items from the i-th position to the j-th position.
            </summary>
            <param name="from">The item position</param>
            <param name="to">The item position</param>
        </member>
        <member name="M:NBitcoin.ContextStack`1.AsInternalArray">
            <summary>
            Returns a copy of the internal array.
            </summary>
            <returns>A copy of the internal array</returns>
        </member>
        <member name="T:NBitcoin.ContextStack`1.Enumerator">
            <summary>
            Implements a reverse enumerator for the ContextStack
            </summary>
        </member>
        <member name="F:NBitcoin.Sequence.SEQUENCE_LOCKTIME_DISABLE_FLAG">
            <summary>
            If this flag set, CTxIn::nSequence is NOT interpreted as a
            relative lock-time. 
            </summary>
        </member>
        <member name="F:NBitcoin.Sequence.SEQUENCE_LOCKTIME_TYPE_FLAG">
            <summary>
            If CTxIn::nSequence encodes a relative lock-time and this flag
            is set, the relative lock-time has units of 512 seconds,
            otherwise it specifies blocks with a granularity of 1. 
            </summary>
        </member>
        <member name="F:NBitcoin.Sequence.SEQUENCE_LOCKTIME_MASK">
            <summary>
            If CTxIn::nSequence encodes a relative lock-time, this mask is
            applied to extract that lock-time from the sequence field.
            </summary>
        </member>
        <member name="F:NBitcoin.Sequence.SEQUENCE_FINAL">
            <summary>
            Setting nSequence to this value for every input in a transaction
            disables nLockTime. */
            </summary>
            <remarks>
            If this flag set, CTxIn::nSequence is NOT interpreted as a
            relative lock-time. Setting the most significant bit of a
            sequence number disabled relative lock-time.
            </remarks>
        </member>
        <member name="F:NBitcoin.Sequence.SEQUENCE_LOCKTIME_GRANULARITY">
            <summary>
            In order to use the same number of bits to encode roughly the
            same wall-clock duration, and because blocks are naturally
            limited to occur every 600s on average, the minimum granularity
            for time-based relative lock-time is fixed at 512 seconds.
            Converting from CTxIn::nSequence to seconds is performed by
            multiplying by 512 = 2^9, or equivalently shifting up by
            9 bits. 
            </summary>
        </member>
        <member name="T:NBitcoin.SPV.Tracker">
            <summary>
            Idempotent and thread safe for tracking operations belonging to a set of ScriptPubKeys
            </summary>
        </member>
        <member name="M:NBitcoin.SPV.Tracker.Add(NBitcoin.IDestination,System.Boolean,System.Boolean,System.String,System.String)">
            <summary>
            Register the specified ScriptPubKey
            </summary>
            <param name="destination">The destination</param>
            <param name="isRedeemScript">If true, the P2SH of the destination's script will be tracked (Default: false)</param>
            <param name="isInternal">If true, the scriptPubKey will not belong to tracked data, typically, change addresses (Default: false)</param>
            <param name="filter">The filter in which this key will appear (http://eprint.iacr.org/2014/763.pdf)</param>
            <param name="wallet">The wallet name to which it belongs</param>
        </member>
        <member name="M:NBitcoin.SPV.Tracker.Add(NBitcoin.Script,System.Boolean,System.Boolean,System.String,System.String)">
            <summary>
            Register the specified ScriptPubKey
            </summary>
            <param name="scriptPubKey">The ScriptPubKey</param>
            <param name="isRedeemScript">If true, the P2SH of the destination's script will be tracked (Default: false)</param>
            <param name="isInternal">If true, the scriptPubKey will not belong to tracked data, typically, change addresses (Default: false)</param>
            <param name="filter">The filter in which this key will appear (http://eprint.iacr.org/2014/763.pdf)</param>
            <param name="wallet">The wallet name to which it belongs</param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:NBitcoin.SPV.Tracker.Prune(NBitcoin.ConcurrentChain,System.Int32,System.Nullable{System.TimeSpan})" -->
        <member name="M:NBitcoin.SPV.Tracker.Validate">
            <summary>
            Check internal consistency
            </summary>
            <returns></returns>
        </member>
        <member name="T:NBitcoin.SPV.TrackerBehavior">
            <summary>
            Load a bloom filter on the node, and push transactions in the Tracker
            </summary>
        </member>
        <member name="M:NBitcoin.SPV.TrackerBehavior.#ctor(NBitcoin.SPV.Tracker,NBitcoin.ConcurrentChain)">
            <summary>
            Create a new TrackerBehavior instance
            </summary>
            <param name="tracker">The Tracker registering transactions and confirmations</param>
            <param name="chain">The chain used to fetch height of incoming blocks, if null, use the chain of ChainBehavior</param>
        </member>
        <member name="M:NBitcoin.SPV.TrackerBehavior.Scan(NBitcoin.BlockLocator,System.DateTimeOffset)">
            <summary>
            Start a scan, if a scan is already running, will change only if the parameters are anterior
            </summary>
            <param name="locator"></param>
        </member>
        <member name="P:NBitcoin.SPV.TrackerBehavior.FalsePositiveRate">
            <summary>
            The expected false positive rate (between 1.0 and 0)
            </summary>
        </member>
        <member name="P:NBitcoin.SPV.TrackerBehavior.MaximumFalsePositiveRateDifference">
            <summary>
            The maximum accepted false positive rate difference, the node will be disconnected if the actual false positive rate is higher than FalsePositiveRate + MaximumFalsePositiveRateDifference.
            </summary>
        </member>
        <member name="M:NBitcoin.SPV.TrackerBehavior.RefreshBloomFilter">
            <summary>
            Refresh the bloom filter
            </summary>
        </member>
        <member name="M:NBitcoin.SPV.TrackerBehavior.SendMessageAsync(NBitcoin.Protocol.Payload)">
            <summary>
            Send message once the bloom filter is set
            </summary>
            <param name="payload">Message to send</param>
        </member>
        <member name="M:NBitcoin.SPV.WalletCreation.#ctor(NBitcoin.BitcoinExtPubKey)">
            <summary>
            Create a P2PKH wallet with one key
            </summary>
            <param name="rootKey">The master key to use</param>
        </member>
        <member name="T:NBitcoin.SPV.Wallet">
            <summary>
            A SPV Wallet respecting recommendation for privacy http://eprint.iacr.org/2014/763.pdf
            </summary>
        </member>
        <member name="E:NBitcoin.SPV.Wallet.NewWalletTransaction">
            <summary>
            Get incoming transactions of the wallet, subscribers should not make any blocking call
            </summary>
        </member>
        <member name="P:NBitcoin.SPV.Wallet.Created">
            <summary>
            Blocks below this date will not be processed
            </summary>
        </member>
        <member name="M:NBitcoin.SPV.Wallet.#ctor(NBitcoin.SPV.WalletCreation,System.Int32)">
            <summary>
            Create a new wallet
            </summary>
            <param name="creation">Creation parameters</param>
            <param name="keyPoolSize">The number of keys which will be pre-created</param>
        </member>
        <member name="M:NBitcoin.SPV.Wallet.#ctor(NBitcoin.BitcoinExtPubKey,System.Int32)">
            <summary>
            Create a new wallet P2PKH with one key
            </summary>
            <param name="rootKey"></param>
            <param name="keyPoolSize"></param>
        </member>
        <member name="M:NBitcoin.SPV.Wallet.GetKeyPath(NBitcoin.Script)">
            <summary>
            Get the KeyPath of the given scriptPubKey
            </summary>
            <param name="scriptPubKey">ScriptPubKey</param>
            <returns>The key path to the scriptPubKey</returns>
        </member>
        <member name="M:NBitcoin.SPV.Wallet.Configure(NBitcoin.ConcurrentChain,NBitcoin.Protocol.AddressManager,NBitcoin.SPV.Tracker)">
            <summary>
            Configure the components of the wallet
            </summary>
            <param name="chain">The chain to keep in sync, if not provided the whole chain will be downloaded on the network (more than 30MB)</param>
            <param name="addrman">The Address Manager for speeding up peer discovery</param>
            <param name="tracker">The tracker responsible for providing bloom filters</param>
        </member>
        <member name="M:NBitcoin.SPV.Wallet.Configure(NBitcoin.Protocol.NodeConnectionParameters)">
            <summary>
            Configure the components of the wallet
            </summary>
            <param name="parameters">The parameters to the connection</param>
        </member>
        <member name="M:NBitcoin.SPV.Wallet.Configure(NBitcoin.Protocol.NodesGroup)">
            <summary>
            Configure the components of the wallet
            </summary>
            <param name="group">The group to use</param>
        </member>
        <member name="M:NBitcoin.SPV.Wallet.Connect">
            <summary>
            Start the connection to the NodeGroup
            </summary>
        </member>
        <member name="M:NBitcoin.SPV.Wallet.BroadcastTransactionAsync(NBitcoin.Transaction)">
            <summary>
            Broadcast a transaction, if the same template behavior as been used for other nodes, they will also broadcast
            </summary>
            <param name="transaction">The transaction to broadcast</param>
            <returns>The cause of the rejection or null</returns>
        </member>
        <member name="M:NBitcoin.PayToPubkeyTemplate.ExtractScriptPubKeyParameters(NBitcoin.Script)">
            <summary>
            Extract the public key or null from the script, perform quick check on pubkey
            </summary>
            <param name="scriptPubKey"></param>
            <returns>The public key</returns>
        </member>
        <member name="M:NBitcoin.PayToPubkeyTemplate.ExtractScriptPubKeyParameters(NBitcoin.Script,System.Boolean)">
            <summary>
            Extract the public key or null from the script
            </summary>
            <param name="scriptPubKey"></param>
            <param name="deepCheck">Whether deep checks are done on public key</param>
            <returns>The public key</returns>
        </member>
        <member name="M:NBitcoin.PayToWitScriptHashTemplate.ExtractWitScriptParameters(NBitcoin.WitScript,NBitcoin.WitScriptId)">
            <summary>
            Extract witness redeem from WitScript
            </summary>
            <param name="witScript">Witscript to extract information from</param>
            <param name="expectedScriptId">Expected redeem hash</param>
            <returns>The witness redeem</returns>
        </member>
        <member name="M:NBitcoin.Stealth.BitcoinStealthAddress.GetPayments(NBitcoin.Transaction,NBitcoin.Key)">
            <summary>
            Scan the Transaction for StealthCoin given address and scan key
            </summary>
            <param name="tx">The transaction to scan</param>
            <param name="address">The stealth address</param>
            <param name="scan">The scan private key</param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.Stealth.BitcoinStealthAddress.GetPayments(NBitcoin.Transaction,NBitcoin.ISecret)">
            <summary>
            Scan the Transaction for StealthCoin given address and scan key
            </summary>
            <param name="tx">The transaction to scan</param>
            <param name="address">The stealth address</param>
            <param name="scan">The scan private key</param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.Stealth.BitcoinStealthAddress.CreatePayment(NBitcoin.Key)">
            <summary>
            Prepare a stealth payment 
            </summary>
            <param name="ephemKey">Ephem Key</param>
            <returns>Stealth Payment</returns>
        </member>
        <member name="M:NBitcoin.Stealth.BitcoinStealthAddress.SendTo(NBitcoin.Transaction,NBitcoin.Money,NBitcoin.Key)">
            <summary>
            Add a stealth payment to the transaction
            </summary>
            <param name="transaction">Destination transaction</param>
            <param name="value">Money to send</param>
            <param name="ephemKey">Ephem Key</param>
        </member>
        <member name="T:NBitcoin.Target">
            <summary>
            Represent the challenge that miners must solve for finding a new block
            </summary>
        </member>
        <member name="M:NBitcoin.TxIn.GetSigner">
            <summary>
            Try to get the expected scriptPubKey of this TxIn based on its scriptSig and witScript.
            </summary>
            <returns>Null if could not infer the scriptPubKey, else, the expected scriptPubKey</returns>
        </member>
        <member name="P:NBitcoin.TxIn.WitScript">
            <summary>
            The witness script (Witness script is not serialized and deserialized at the TxIn level, but at the Transaction level)
            </summary>
        </member>
        <member name="P:NBitcoin.IndexedTxIn.Index">
            <summary>
            The index of this TxIn in its transaction
            </summary>
        </member>
        <member name="M:NBitcoin.WitScript.#ctor(System.Byte[][],System.Boolean)">
            <summary>
            Create a new WitnessScript
            </summary>
            <param name="script">Scripts</param>
            <param name="unsafe">If false, make a copy of the input script array</param>
        </member>
        <member name="M:NBitcoin.WitScript.#ctor(System.Collections.Generic.IEnumerable{System.Byte[]},System.Boolean)">
            <summary>
            Create a new WitnessScript
            </summary>
            <param name="script">Scripts</param>
        </member>
        <member name="M:NBitcoin.Transaction.PrecomputeHash(System.Boolean,System.Boolean)">
            <summary>
            Precompute the transaction hash and witness hash so that later calls to GetHash() and GetWitHash() will returns the precomputed hash
            </summary>
            <param name="invalidateExisting">If true, the previous precomputed hash is thrown away, else it is reused</param>
            <param name="lazily">If true, the hash will be calculated and cached at the first call to GetHash(), else it will be immediately</param>
        </member>
        <member name="M:NBitcoin.Transaction.GetVirtualSize">
            <summary>
            Size of the transaction discounting the witness (Used for fee calculation)
            </summary>
            <returns>Transaction size</returns>
        </member>
        <member name="M:NBitcoin.Transaction.Sign(NBitcoin.ISecret[],NBitcoin.ICoin[])">
            <summary>
            Sign a specific coin with the given secret
            </summary>
            <param name="secrets">Secrets</param>
            <param name="coins">Coins to sign</param>
        </member>
        <member name="M:NBitcoin.Transaction.Sign(NBitcoin.Key[],NBitcoin.ICoin[])">
            <summary>
            Sign a specific coin with the given secret
            </summary>
            <param name="keys">Private keys</param>
            <param name="coins">Coins to sign</param>
        </member>
        <member name="M:NBitcoin.Transaction.Sign(NBitcoin.ISecret,NBitcoin.ICoin[])">
            <summary>
            Sign a specific coin with the given secret
            </summary>
            <param name="secret">Secret</param>
            <param name="coins">Coins to sign</param>
        </member>
        <member name="M:NBitcoin.Transaction.Sign(NBitcoin.ISecret[],NBitcoin.ICoin)">
            <summary>
            Sign a specific coin with the given secret
            </summary>
            <param name="secrets">Secrets</param>
            <param name="coins">Coins to sign</param>
        </member>
        <member name="M:NBitcoin.Transaction.Sign(NBitcoin.ISecret,NBitcoin.ICoin)">
            <summary>
            Sign a specific coin with the given secret
            </summary>
            <param name="secret">Secret</param>
            <param name="coin">Coins to sign</param>
        </member>
        <member name="M:NBitcoin.Transaction.Sign(NBitcoin.Key,NBitcoin.ICoin[])">
            <summary>
            Sign a specific coin with the given secret
            </summary>
            <param name="key">Private key</param>
            <param name="coins">Coins to sign</param>
        </member>
        <member name="M:NBitcoin.Transaction.Sign(NBitcoin.Key,NBitcoin.ICoin)">
            <summary>
            Sign a specific coin with the given secret
            </summary>
            <param name="key">Private key</param>
            <param name="coin">Coin to sign</param>
        </member>
        <member name="M:NBitcoin.Transaction.Sign(NBitcoin.Key[],NBitcoin.ICoin)">
            <summary>
            Sign a specific coin with the given secret
            </summary>
            <param name="keys">Private keys</param>
            <param name="coin">Coin to sign</param>
        </member>
        <member name="M:NBitcoin.Transaction.Sign(NBitcoin.ISecret,System.Boolean)">
            <summary>
            Sign the transaction with a private key
            <para>ScriptSigs should be filled with previous ScriptPubKeys</para>
            <para>For more complex scenario, use TransactionBuilder</para>
            </summary>
            <param name="secret"></param>
        </member>
        <member name="M:NBitcoin.Transaction.Sign(NBitcoin.Key,System.Boolean)">
            <summary>
            Sign the transaction with a private key
            <para>ScriptSigs should be filled with either previous scriptPubKeys or redeem script (for P2SH)</para>
            <para>For more complex scenario, use TransactionBuilder</para>
            </summary>
            <param name="secret"></param>
        </member>
        <member name="M:NBitcoin.Transaction.GetFee(NBitcoin.ICoin[])">
            <summary>
            Calculate the fee of the transaction
            </summary>
            <param name="spentCoins">Coins being spent</param>
            <returns>Fee or null if some spent coins are missing or if spentCoins is null</returns>
        </member>
        <member name="M:NBitcoin.Transaction.GetFeeRate(NBitcoin.ICoin[])">
            <summary>
            Calculate the fee rate of the transaction
            </summary>
            <param name="spentCoins">Coins being spent</param>
            <returns>Fee or null if some spent coins are missing or if spentCoins is null</returns>
        </member>
        <member name="F:NBitcoin.Transaction.LockTimeFlags.VerifySequence">
            <summary>
            Interpret sequence numbers as relative lock-time constraints.
            </summary>
        </member>
        <member name="F:NBitcoin.Transaction.LockTimeFlags.MedianTimePast">
            <summary>
             Use GetMedianTimePast() instead of nTime for end point timestamp.
            </summary>
        </member>
        <member name="M:NBitcoin.Transaction.CheckSequenceLocks(System.Int32[],NBitcoin.ChainedBlock,NBitcoin.Transaction.LockTimeFlags)">
            <summary>
            Calculates the block height and time which the transaction must be later than
            in order to be considered final in the context of BIP 68.  It also removes
            from the vector of input heights any entries which did not correspond to sequence
            locked inputs as they do not affect the calculation.
            </summary>		
            <param name="prevHeights">Previous Height</param>
            <param name="block">The block being evaluated</param>
            <param name="flags">If VerifySequence is not set, returns always true SequenceLock</param>
            <returns>Sequence lock of minimum SequenceLock to satisfy</returns>
        </member>
        <member name="M:NBitcoin.Transaction.CalculateSequenceLocks(System.Int32[],NBitcoin.ChainedBlock,NBitcoin.Transaction.LockTimeFlags)">
            <summary>
            Calculates the block height and time which the transaction must be later than
            in order to be considered final in the context of BIP 68.  It also removes
            from the vector of input heights any entries which did not correspond to sequence
            locked inputs as they do not affect the calculation.
            </summary>		
            <param name="prevHeights">Previous Height</param>
            <param name="block">The block being evaluated</param>
            <param name="flags">If VerifySequence is not set, returns always true SequenceLock</param>
            <returns>Sequence lock of minimum SequenceLock to satisfy</returns>
        </member>
        <member name="M:NBitcoin.Transaction.WithOptions(NBitcoin.TransactionOptions)">
            <summary>
            Create a transaction with the specified option only. (useful for stripping data from a transaction)
            </summary>
            <param name="options">Options to keep</param>
            <returns>A new transaction with only the options wanted</returns>
        </member>
        <member name="M:NBitcoin.Transaction.Check">
            <summary>
            Context free transaction check
            </summary>
            <returns>The error or success of the check</returns>
        </member>
        <member name="T:NBitcoin.DefaultCoinSelector">
            <summary>
            Algorithm implemented by bitcoin core https://github.com/bitcoin/bitcoin/blob/master/src/wallet.cpp#L1276
            Minimize the change
            </summary>
        </member>
        <member name="P:NBitcoin.DefaultCoinSelector.GroupByScriptPubKey">
            <summary>
            Select all coins belonging to same scriptPubKey together to protect privacy. (Default: true)
            </summary>
        </member>
        <member name="T:NBitcoin.NotEnoughFundsException">
            <summary>
            Exception thrown when not enough funds are present for verifying or building a transaction
            </summary>
        </member>
        <member name="P:NBitcoin.NotEnoughFundsException.Group">
            <summary>
            The group name who is missing the funds
            </summary>
        </member>
        <member name="P:NBitcoin.NotEnoughFundsException.Missing">
            <summary>
            Amount of Money missing
            </summary>
        </member>
        <member name="T:NBitcoin.TransactionBuilder">
            <summary>
            A class for building and signing all sort of transactions easily (http://www.codeproject.com/Articles/835098/NBitcoin-Build-Them-All)
            </summary>
        </member>
        <member name="P:NBitcoin.TransactionBuilder.DustPrevention">
            <summary>
            If true, it will remove any TxOut below Dust, so the transaction get correctly relayed by the network. (Default: true)
            </summary>
        </member>
        <member name="P:NBitcoin.TransactionBuilder.MergeOutputs">
            <summary>
            If true and the transaction has two outputs sending to the same scriptPubKey, those will be merged into a single output. (Default: true)
            </summary>
        </member>
        <member name="P:NBitcoin.TransactionBuilder.FilterUneconomicalCoins">
            <summary>
            If true, the TransactionBuilder will not select coins whose fee to spend is higher than its value. (Default: true)
            The cost of spending a coin is based on the <see cref="P:NBitcoin.TransactionBuilder.FilterUneconomicalCoinsRate"/>.
            </summary>
        </member>
        <member name="P:NBitcoin.TransactionBuilder.FilterUneconomicalCoinsRate">
            <summary>
            If <see cref="P:NBitcoin.TransactionBuilder.FilterUneconomicalCoins"/> is true, this rate is used to know if an output is economical.
            This property is set automatically when calling <see cref="M:NBitcoin.TransactionBuilder.SendEstimatedFees(NBitcoin.FeeRate)"/> or <see cref="M:NBitcoin.TransactionBuilder.SendEstimatedFeesSplit(NBitcoin.FeeRate)"/>.
            </summary>
        </member>
        <member name="P:NBitcoin.TransactionBuilder.CoinFinder">
            <summary>
            A callback used by the TransactionBuilder when it does not find the coin for an input
            </summary>
        </member>
        <member name="P:NBitcoin.TransactionBuilder.KeyFinder">
            <summary>
            A callback used by the TransactionBuilder when it does not find the key for a scriptPubKey
            </summary>
        </member>
        <member name="M:NBitcoin.TransactionBuilder.SetGroupName(System.String)">
            <summary>
            Set the name of this group (group are separated by call to Then())
            </summary>
            <param name="groupName">Name of the group</param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.TransactionBuilder.Send(NBitcoin.IDestination,NBitcoin.Money)">
            <summary>
            Send bitcoins to a destination
            </summary>
            <param name="destination">The destination</param>
            <param name="amount">The amount</param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.TransactionBuilder.Send(NBitcoin.Script,NBitcoin.Money)">
            <summary>
            Send bitcoins to a destination
            </summary>
            <param name="scriptPubKey">The destination</param>
            <param name="amount">The amount</param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.TransactionBuilder.SubtractFees">
            <summary>
            Will subtract fees from the previous TxOut added by the last TransactionBuidler.Send() call
            </summary>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.TransactionBuilder.Send(NBitcoin.IDestination,NBitcoin.IMoney)">
            <summary>
            Send a money amount to the destination
            </summary>
            <param name="destination">The destination</param>
            <param name="amount">The amount (supported : Money, AssetMoney, MoneyBag)</param>
            <returns></returns>
            <exception cref="T:System.NotSupportedException">The coin type is not supported</exception>
        </member>
        <member name="M:NBitcoin.TransactionBuilder.Send(NBitcoin.Script,NBitcoin.IMoney)">
            <summary>
            Send a money amount to the destination
            </summary>
            <param name="destination">The destination</param>
            <param name="amount">The amount (supported : Money, AssetMoney, MoneyBag)</param>
            <returns></returns>
            <exception cref="T:System.NotSupportedException">The coin type is not supported</exception>
        </member>
        <member name="M:NBitcoin.TransactionBuilder.SendAsset(NBitcoin.IDestination,NBitcoin.OpenAsset.AssetMoney)">
            <summary>
            Send assets (Open Asset) to a destination
            </summary>
            <param name="destination">The destination</param>
            <param name="asset">The asset and amount</param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.TransactionBuilder.SendAsset(NBitcoin.IDestination,NBitcoin.OpenAsset.AssetId,System.UInt64)">
            <summary>
            Send assets (Open Asset) to a destination
            </summary>
            <param name="destination">The destination</param>
            <param name="asset">The asset and amount</param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.TransactionBuilder.SetTransactionPolicy(NBitcoin.Policy.StandardTransactionPolicy)">
            <summary>
            Set transaction policy fluently
            </summary>
            <param name="policy">The policy</param>
            <returns>this</returns>
        </member>
        <member name="M:NBitcoin.TransactionBuilder.SendEstimatedFees(NBitcoin.FeeRate)">
            <summary>
            Split the estimated fees accross the several groups (separated by Then())
            </summary>
            <param name="feeRate"></param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.TransactionBuilder.SendEstimatedFeesSplit(NBitcoin.FeeRate)">
            <summary>
            Estimate the fee needed for the transaction, and split among groups according to their fee weight
            </summary>
            <param name="feeRate"></param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.TransactionBuilder.SendFeesSplit(NBitcoin.Money)">
            <summary>
            Send the fee splitted among groups according to their fee weight
            </summary>
            <param name="fees"></param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.TransactionBuilder.SetFeeWeight(System.Decimal)">
            <summary>
            If using SendFeesSplit or SendEstimatedFeesSplit, determine the weight this group participate in paying the fees
            </summary>
            <param name="feeWeight">The weight of fee participation</param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.TransactionBuilder.BuildTransaction(System.Boolean)">
            <summary>
            Build the transaction
            </summary>
            <param name="sign">True if signs all inputs with the available keys</param>
            <returns>The transaction</returns>
            <exception cref="T:NBitcoin.NotEnoughFundsException">Not enough funds are available</exception>
        </member>
        <member name="M:NBitcoin.TransactionBuilder.BuildTransaction(System.Boolean,NBitcoin.SigHash)">
            <summary>
            Build the transaction
            </summary>
            <param name="sign">True if signs all inputs with the available keys</param>
            <param name="sigHash">The type of signature</param>
            <returns>The transaction</returns>
            <exception cref="T:NBitcoin.NotEnoughFundsException">Not enough funds are available</exception>
        </member>
        <member name="M:NBitcoin.TransactionBuilder.Verify(NBitcoin.Transaction)">
            <summary>
            Verify that a transaction is fully signed and have enough fees
            </summary>
            <param name="tx">The transaction to check</param>
            <returns>True if no error</returns>
        </member>
        <member name="M:NBitcoin.TransactionBuilder.Verify(NBitcoin.Transaction,NBitcoin.Money)">
            <summary>
            Verify that a transaction is fully signed and have enough fees
            </summary>
            <param name="tx">The transaction to check</param>
            <param name="expectedFees">The expected fees (more or less 10%)</param>
            <returns>True if no error</returns>
        </member>
        <member name="M:NBitcoin.TransactionBuilder.Verify(NBitcoin.Transaction,NBitcoin.FeeRate)">
            <summary>
            Verify that a transaction is fully signed and have enough fees
            </summary>
            <param name="tx">The transaction to check</param>
            <param name="expectedFeeRate">The expected fee rate</param>
            <returns>True if no error</returns>
        </member>
        <member name="M:NBitcoin.TransactionBuilder.Verify(NBitcoin.Transaction,NBitcoin.Policy.TransactionPolicyError[]@)">
            <summary>
            Verify that a transaction is fully signed and have enough fees
            </summary>
            <param name="tx">The transaction to check</param>
            <param name="errors">Detected errors</param>
            <returns>True if no error</returns>
        </member>
        <member name="M:NBitcoin.TransactionBuilder.Verify(NBitcoin.Transaction,NBitcoin.Money,NBitcoin.Policy.TransactionPolicyError[]@)">
            <summary>
            Verify that a transaction is fully signed, have enough fees, and follow the Standard and Miner Transaction Policy rules
            </summary>
            <param name="tx">The transaction to check</param>
            <param name="expectedFees">The expected fees (more or less 10%)</param>
            <param name="errors">Detected errors</param>
            <returns>True if no error</returns>
        </member>
        <member name="M:NBitcoin.TransactionBuilder.Verify(NBitcoin.Transaction,NBitcoin.FeeRate,NBitcoin.Policy.TransactionPolicyError[]@)">
            <summary>
            Verify that a transaction is fully signed and have enough fees
            </summary>
            <param name="tx">The transaction to check</param>
            <param name="expectedFeeRate">The expected fee rate</param>
            <param name="errors">Detected errors</param>
            <returns>True if no error</returns>
        </member>
        <member name="M:NBitcoin.TransactionBuilder.Check(NBitcoin.Transaction,NBitcoin.FeeRate)">
            <summary>
            Verify that a transaction is fully signed and have enough fees
            </summary>
            <param name="tx">he transaction to check</param>
            <param name="expectedFeeRate">The expected fee rate</param>
            <returns>Detected errors</returns>
        </member>
        <member name="M:NBitcoin.TransactionBuilder.Check(NBitcoin.Transaction,NBitcoin.Money)">
            <summary>
            Verify that a transaction is fully signed and have enough fees
            </summary>
            <param name="tx">he transaction to check</param>
            <param name="expectedFee">The expected fee</param>
            <returns>Detected errors</returns>
        </member>
        <member name="M:NBitcoin.TransactionBuilder.Check(NBitcoin.Transaction)">
            <summary>
            Verify that a transaction is fully signed and have enough fees
            </summary>
            <param name="tx">he transaction to check</param>
            <returns>Detected errors</returns>
        </member>
        <member name="M:NBitcoin.TransactionBuilder.FindSpentCoins(NBitcoin.Transaction)">
            <summary>
            Find spent coins of a transaction
            </summary>
            <param name="tx">The transaction</param>
            <returns>Array of size tx.Input.Count, if a coin is not fund, a null coin is returned.</returns>
        </member>
        <member name="M:NBitcoin.TransactionBuilder.EstimateSize(NBitcoin.Transaction)">
            <summary>
            Estimate the physical size of the transaction
            </summary>
            <param name="tx">The transaction to be estimated</param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.TransactionBuilder.EstimateSize(NBitcoin.Transaction,System.Boolean)">
            <summary>
            Estimate the size of the transaction
            </summary>
            <param name="tx">The transaction to be estimated</param>
            <param name="virtualSize">If true, returns the size on which fee calculation are based, else returns the physical byte size</param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.TransactionBuilder.EstimateFees(NBitcoin.FeeRate)">
            <summary>
            Estimate fees of the built transaction
            </summary>
            <param name="feeRate">Fee rate</param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.TransactionBuilder.EstimateFees(NBitcoin.Transaction,NBitcoin.FeeRate)">
            <summary>
            Estimate fees of an unsigned transaction
            </summary>
            <param name="tx"></param>
            <param name="feeRate">Fee rate</param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.TransactionBuilder.Then">
            <summary>
            Create a new participant in the transaction with its own set of coins and keys
            </summary>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.TransactionBuilder.Then(System.String)">
            <summary>
            Switch to another participant in the transaction, or create a new one if it is not found.
            </summary>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.TransactionBuilder.CoverOnly(NBitcoin.Money)">
            <summary>
            Specify the amount of money to cover txouts, if not specified all txout will be covered
            </summary>
            <param name="amount"></param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.TransactionBuilder.ContinueToBuild(NBitcoin.Transaction)">
            <summary>
            Allows to keep building on the top of a partially built transaction
            </summary>
            <param name="transaction">Transaction to complete</param>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.TransactionBuilder.CoverTheRest">
            <summary>
            Will cover the remaining amount of TxOut of a partially built transaction (to call after ContinueToBuild)
            </summary>
            <returns></returns>
        </member>
        <member name="M:NBitcoin.TransactionSignature.IsValid(System.Byte[],NBitcoin.ScriptVerify)">
            <summary>
            Check if valid transaction signature
            </summary>
            <param name="sig">Signature in bytes</param>
            <param name="scriptVerify">Verification rules</param>
            <returns>True if valid</returns>
        </member>
        <member name="M:NBitcoin.TransactionSignature.IsValid(System.Byte[],NBitcoin.ScriptVerify,NBitcoin.ScriptError@)">
            <summary>
            Check if valid transaction signature
            </summary>
            <param name="sig">The signature</param>
            <param name="scriptVerify">Verification rules</param>
            <param name="error">Error</param>
            <returns>True if valid</returns>
        </member>
        <member name="M:NBitcoin.TransactionSignature.MakeCanonical">
            <summary>
            Enforce LowS on the signature
            </summary>
        </member>
        <member name="M:NBitcoin.Extensions.ToUnixTimestamp(System.DateTime)">
            <summary>
            Converts a given DateTime into a Unix timestamp
            </summary>
            <param name="value">Any DateTime</param>
            <returns>The given DateTime in Unix timestamp format</returns>
        </member>
        <member name="M:NBitcoin.Extensions.UnixTimestamp(System.DateTime)">
            <summary>
            Gets a Unix timestamp representing the current moment
            </summary>
            <param name="ignored">Parameter ignored</param>
            <returns>Now expressed as a Unix timestamp</returns>
        </member>
        <member name="M:NBitcoin.ThreadSafeCollection`1.Add(`0)">
            <summary>
            Add an item to the collection
            </summary>
            <param name="item"></param>
            <returns>When disposed, the item is removed</returns>
        </member>
    </members>
</doc>
